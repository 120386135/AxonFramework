<?xml version="1.0" encoding="UTF-8"?>

<!--
  ~ Copyright (c) 2010. Axon Framework
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~     http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->
<chapter id="building-blocks" xmlns="http://docbook.org/ns/docbook">
  <title>Building Blocks</title>
  <figure>
    <title>Architecture overview of a CQRS application</title>
    <mediaobject>
      <imageobject>
        <info>Detailed architecture overview</info>
        <imagedata fileref="detailed-architecture-overview.png" width="300pt"/>
      </imageobject>
    </mediaobject>
  </figure>
  <sect1>
    <title xml:id="events">Events</title>
    <para>The Axon Framework makes a distinction between three types of events, each with a clear
      use and type of origin. Regardless of their type, all events must implement the
        <code>Event</code> interface or one of the more specific sub-types, each described in the
      sections below.</para>
    <sect2>
      <title>Domain Events</title>
      <para>The most important type of event in any CQRS application is the domain event. It
        represents an event that occurs inside your domain logic, such as a state change or special
        notification of a certain state. The latter not being per definition a state change.</para>
      <para>In the Axon Framework, all domain events should extend the abstract
          <code>DomainEvent</code> class. This abstract class keeps track of the aggregate they are
        generated by, and the sequence number of the event inside the aggregate. This information is
        important for the Event Sourcing mechanism, as well as for event handlers (see <xref
                  linkend="event-listeners"/>) that need to know the origin of an event.</para>
      <para>Although not enforced, it is good practice to make domain events immutable, preferably
        by making all fields final and by initializing the event within the constructor.</para>
      <note>
        <para>Although Domain Events technically indicate a state change, you should try to capture
          the intention of the state in the event, too. A good practice is to use an abstract
          implementation of a domain event to capture the fact that certain state has changed, and
          use a concrete sub-implementation of that abstract class that indicates the intention of
          the change. For example, you could have an abstract <code>OrderStatusChangedEvent</code>,
          and two implementations <code>OrderCancelledByUser</code> and
            <code>OrderCancelledByAdministrator</code> that capture the intent of the state change.
          Some listeners will care about the intent (e.g. to select a mail template when notifying
          the customer), while others don't (e.g. database updating event listeners). The latter
          will listen to events of the abstract type, while the former will listen to the concrete
          subtypes.</para>
      </note>
    </sect2>
    <sect2>
      <title>Application Events</title>
      <para>Application events are events that cannot be categorized as domain events, but do have a
        significant importance for the application. When using application events, you should always
        consider the fact that you might have overlooked an type of domain event. Examples of
        application events could be the expiry of a user session, an event reporting the successful
        sending of an email or a validation error on a command. The usefulness of these event depend
        on the type of application you are creating.</para>
      <para>In the Axon Framework, you can extend the abtract <code>ApplicationEvent</code> class
        for application events. This class will generate a unique identifier and a time stamp for
        the current event. Optionally, you can attach a class that acts as the source of the event.
        This source is loosely attached, which means that if the garbage collector cleans up the
        source, or when the event is serialized and deserialized, the original source class is not
        available anymore. Instead, you will have access to the type of source and the value of it's
          <code>toString()</code> method.</para>
    </sect2>
    <sect2>
      <title>System Events</title>
      <para>The third type of event identified by Axon Framework is the System Event. These events
        typically provide notifications of the status of the system. These events could, for
        example, indicate that a subsystem is non-responsive or has raised an exception.</para>
      <para>System events extends the abstract <code>SystemEvent</code> class. Upon construction of
        this event, you may pass an exception, defining the cause of the event, and a source object
        which is considered the source of the event. This object is loosely referenced from the
        event, which means that if the garbage collector cleans up the source, or when the event is
        serialized and deserialized, the original source class is not available anymore. Instead,
        you will have access to the type of source and the value of it's <code>toString()</code>
        method.</para>
    </sect2>
  </sect1>
  <sect1>
    <title>Aggregate</title>
    <para>An Aggregate is an entity or group of entities that is always kept in a consistent state.
      The aggregate root is the object on top of the aggregate tree that is responsible for
      maintaining this consistent state. </para>
    <para>For example, an "Order" aggregate will contain two entities: order and order item. To keep
      the entire aggregate in a consistent state, adding an order item should be done via the order
      entity. In this case, the order entity is the appointed aggregate root. For example, an
      "Order" aggregate will contain two entities: order and order item. To keep the entire
      aggregate in a consistent state, adding an order item should be done via the order entity. In
      this case, the order entity is the appointed aggregate root.</para>
    <sect2>
      <title>Basic aggregate implementations</title>
      <simplesect>
        <title><code xmlns="http://docbook.org/ns/docbook">AggregateRoot</code></title>
        <para>In Axon, all aggregate roots must implement the <code>AggregateRoot</code> interface.
          This interface describes that basic operations needed by the Repository to store and
          publish the generated domain events. There are, however, a number of abstract
          implementations that provide basic functionality.</para>
        <note>
          <para>Note that only the aggregate root needs to implement the AggregateRoot interface or
            implement one of the abstract classes mentioned below. The other entities that are part
            of the aggregate do not have to implement any interfaces.</para>
        </note>
      </simplesect>
      <simplesect>
        <title><code>VersionedAggregateRoot</code></title>
        <para>The <code>VersionedAggregateRoot</code> interface provides the information needed by
          repositories to perform optimistic locking. The only method added to the
            <code>AggregateRoot</code> interface is
          <code>getLastCommittedEventSequenceNumber</code>, which returns the sequence number of the
          event that was last committed.</para>
        <para>See <xref linkend="locking-repository"/> for more information about the abstract
            <code>LockingRepository</code> implementation.</para>
      </simplesect>
      <simplesect>
        <title><code>AbstractAggregateRoot</code></title>
        <para>The <code>AbstractAggregateRoot</code> is a basic implementation that requires you to
          override the handle method to implement the state change logic. This abstract class
          provides an apply method that you can call in your business logic method to have an event
          applied. The <code>AbstractAggregateRoot</code> will keep track of all uncommitted applied
          events and make sure they are forwarded to the event bus when the aggregate is saved to a
          repository.</para>
      </simplesect>
    </sect2>
    <sect2>
      <title>Event sourcing aggregates</title>
      <para>Axon framework provides a few repository implementations that can use event sourcing as
        storage method for aggregates. These repositories require that aggregates implement the
          <code>EventSourcedAggregateRoot</code> interface. As with most interfaces in Axon, we also
        provide one or more abstract implementation to help you on your way.</para>
      <simplesect>
        <title><code>EventSourcedAggregateRoot</code></title>
        <para>The <code>EventSourcedAggregateRoot</code> provides an extra method on top of the
            <code>VersionedAggregateRoot</code>: <code>initializeState()</code>. This method allows
          a repository to initialize the aggregate's state based on an event stream.</para>
      </simplesect>
      <simplesect>
        <title><code>AbstractEventSourcedAggregateRoot</code></title>
        <para>The <code>AbstractEventSourcedAggregateRoot</code> implements all methods on the
            <code>EventSourcedAggregateRoot</code> interface. All you need to implement is the
            <code>handle()</code> method, which contains the actual logic to change state based on
          information in the events. When you extend the
            <code>AbstractEventSourcedAggregateRoot</code>, you can register new events using the
            <code>apply()</code> method. This method will register the event to be committed when
          the aggregate is saved, and will call the <code>handle()</code> method with the event as
          parameter.</para>
        <programlisting language="java">public class MyAggregateRoot extends AbstractEventSourcedAggregateRoot {
  private String someProperty;

  public MyAggregateRoot() {
    apply(new MyAggregateCreatedEvent());
  }

  public MyAggregateRoot(UUID identifier) {
    super(identifier);
  }

  public void handle(DomainEvent event) {
    if (event instanceof MyAggregateCreatedEvent) {
      // do something with someProperty
    }
    // and more if-else-if logic here
  }
}</programlisting>
      </simplesect>
      <simplesect>
        <title><code xml:id="annotated-aggregate-root">AbstractAnnotatedAggregateRoot</code></title>
        <para>As you see, the implementation of the <code>handle()</code> method can become quite
          verbose and hard to read. The <code>AbstractAnnotatedAggregateRoot</code> can help. The
            <code>AbstractAnnotatedAggregateRoot</code> is a specialization of the
            <code>AbstractAggregateRoot</code> that provides <code>@EventHandler</code> annotation
          support to your aggregate. Instead of a single <code>handle()</code> method, you can split
          the logic in separate methods, with names that you may define yourself. Just annotate the
          event handler methods with <code>@EventHandler</code>, and the
            <code>AbstractAnnotatedAggregateRoot</code> will invoke the right method for you.</para>
        <programlisting language="java">public class MyAggregateRoot extends AbstractEventSourcedAggregateRoot {
  private String someProperty;

  public MyAggregateRoot() {
    apply(new MyAggregateCreatedEvent());
  }

  public MyAggregateRoot(UUID identifier) {
    super(identifier);
  }

  @EventHandler
  private void handleMyAggregateCreatedEvent(MyAggregateCreatedEvent event) {
      // do something with someProperty
  }
}</programlisting>
        <para>In all circumstances, exactly one single event handler method is invoked. The
            <code>AbstractAnnotatedAggregateRoot</code> will search the most specific method to
          invoke, in the following order:</para>
        <orderedlist>
          <listitem>
            <para>On the actual instance level of the class hierarchy (as returned by
                <code>this.getClass()</code>), all annotated methods are evaluated</para>
          </listitem>
          <listitem>
            <para>If one or methods are found of which the parameter is of the event type or a super
              type, the method with the most specific class (the subclass) is chosen and
              invoked</para>
          </listitem>
          <listitem>
            <para>If no methods are found on this level of the class hierarchy, the super type is
              evaluated the same way</para>
          </listitem>
          <listitem>
            <para>When the level of the <code>AbstractAnnotatedAggregateRoot</code> is reached, and
              no suitable event handler is found, an <code>UnhandledEventException</code> is
              thrown.</para>
          </listitem>
        </orderedlist>
        <para>Event handler methods may be private, as long as the security settings of the JVM
          allow the Axon Framework to change the accessibility of the method. This allows you to
          clearly separate the public API of your aggregate, which exposes the methods that generate
          events, from the internal logic, which processes the events.</para>
        <tip>
          <para>If you have some events that have no direct effect on any fields in the aggregate,
            you can choose to create a <code>handleOtherEvents(DomainEvent event)</code> method with
            an empty body. This will prevent any exception being thrown. Do consider, however, that
            doing so may result in unexpected behavior if an event handler for a specific type of
            event is forgotten.</para>
        </tip>
      </simplesect>
    </sect2>
  </sect1>
  <sect1>
    <title>Repository</title>
    <para>TODO: Explain the repository</para>
  </sect1>
  <sect1 xml:id="event-listeners">
    <title xml:id="event-listeners">Event Listeners</title>
    <para linkend="">Event listeners are the component that act on incoming events. These events may
      be of any type of the events mentioned in <xref linkend="events"/>. In the Axon Framework, all
      event listenerrs must implement the <code>EventListener</code> interface. </para>
    <sect2>
      <title>Basic configuration</title>
      <para>Event listeners need to be registered with an event bus (see <xref linkend="event-bus"
              />) to be notified of events. Axon, however, provides a base implementation that take care
        of this, and other things, for you.</para>
      <simplesect>
        <title><code>AnnotationEventListenerAdapter</code></title>
        <para>The <code>AnnotationEventListenerAdapter</code> can wrap any bean into an event
          listener. The adapter will invoke the most appropriate event handler method available.
          These event handler methods must be annotated with the <code>@EventHandler</code>
          annotation and are resolved according to the same rules that count for annotated aggregate
          roots (see <xref linkend="annotated-aggregate-root"/>).</para>
      </simplesect>
      <para>If you use the annotation support features, you can use the
          <code>AnnotationEventListenerAdapter</code> (and subclasses) to turn your annotated pojo
        into a full blown event listener. See annotation support for more information.</para>
      <tip>
        <para>If you use Spring, you can automatically wrap all annotated event listeners with an
          adapter automatically by configuring a bean of type
            <code>AnnotationEventListenerBeanPostProcessor</code>. This post processor will
          automatically find and wrap annotated event listeners inside an
            <code>AnnotationEventListenerAdapter</code> and register them with an event bus.</para>
      </tip>
    </sect2>
    <sect2>
      <title>Concurrent processing of events</title>
      <para>The <code>EventListener</code> interface defines a method called
          <code>getEventSequencingPolicy()</code>. This method should return the policy that tells
        Axon what type of concurrent processing of events this listener supports.</para>
      <para>Axon provides a number of common policies you can use:<itemizedlist>
          <listitem>
            <para>The <code>FullConcurrencyPolicy</code> will tell Axon that this event handler may
              handle all events concurrently. This means that there is no relationship between the
              events that require them to be processed in a particular order.</para>
          </listitem>
          <listitem>
            <para>The <code>SequentialPolicy</code> tells Axon that all events must be processed
              sequentially. Handling of an event will start when the handling of a previous event is
              finished. For annotated event handlers, this is the default policy.</para>
          </listitem>
          <listitem>
            <para><code>SequentialPerAggregatePolicy</code> will force domain events that were
              raised from the same aggregate to be handled sequentially. However, events from
              different aggregates may be handled concurrently. This is typically a suitable policy
              to use for event listeners that update details from aggregates in database
              tables.</para>
          </listitem>
        </itemizedlist></para>
      <para>Besides these provided policies, you can define your own. All policies must implement
        the <code>EventSequencingPolicy</code> interface. This interface defines a single method
        that returns the identifier sequence identifier for an event. Events for which an equals
        sequence identifer is returned must be processed sequentially. Events that produce a
        different sequence identifier may be processed concurrently. For performance reasons, policy
        implementations should return <code>null</code> if the event may be processed in parallel to
        any other event. This is faster, because Axon does not have to check for any restrictions on
        event processing.</para>
      <simplesect>
        <title>Annotation support for concurrent processing</title>
        <para>If you use the <code>AnnotationEventListenerAdapter</code>, you can configure the
          event sequencing policy using the <code>@ConcurrentEventListener</code> annotation. You
          then set the <code>sequencePolicyClass</code> to the type of policy you like to use. Note
          that you can only choose policy classes that provide a public no-arg
          constructor.<programlisting language="java">@ConcurrentEventListener(sequencingPolicyClass = MyCustomPolicy.class)
public class MyEventListener() {
  
  @EventHandler
  public void onSomeImportantEvent(MyEvent event) {
    // eventProcessing logic
  }
}

public class MyCustomPolicy implements EventSequencingPolicy {
  public Object getSequenceIdentifierFor(DomainEvent event) {
    if (event instanceof MyEvent) {
      // let's assume that we do processing based on the someProperty field.
      return ((MyEvent) event).someProperty();
    }
    return null;
  }
}</programlisting></para>
      </simplesect>
    </sect2>
    <sect2>
      <title>Dealing with transactions</title>
      <para>In some cases, your event handlers have to store data in systems that use transactions.
        Starting and committing a transaction for each single event has a big performance impact. In
        Axon, events are processed in batches. The batch size depends of the number of events that
        need to be processed and the settings provided by the event handler. By default, a thread
        will handle the all events in a batch that were present when that batch started processing. </para>
      <para>In most cases, event handling is done using a thread pool executor, or scheduler. The
        scheduler will schedule batches of event processing as soon as event become available. When
        a batch is completed, the scheduler will reschedule processing of the next batch, as long as
        more events are available. The smaller the batch, the more "fair" the distribution of event
        handler processing is, but also the more scheduling overhead you create.</para>
      <para>If Axon dispatches events to an event listener that implemetns the
          <code>TransactionAware</code> interface, it will notify the event listener of the start
        and end of a batch. The event listener can, based on the information in the
          <code>TransactionStatus</code> object, decide to start, commit or rollback a transaction
        to an external system.</para>
      <para>The <code>beforeTransaction(TransactionStatus)</code>  method is invoked just before
        Axon will start handling an event batch. You can use the TransactionStatus object to
        configure the batch before it is started. For example, you can change the maximum number of
        events that may run in the batch. </para>
      <para>The <code>afterTransaction(TransactionStatus)</code> method is invoked after the batch
        has been processed, but before the scheduler has scheduled the next batch. Based on the
        value of <code>isSuccessful()</code>, you can decide to commit or rollback the transaction
        with the datasource the event handler is updating. </para>
      <simplesect>
        <title>Configuring transactional batches</title>
      </simplesect>
      <para>There are a number of settings you can use on the <code>TransactionStatus</code> object. </para>
      <para>You can configure a yielding policy, which gives the scheduler an indication of that to
        do when a batch has finished, but more events are available for processing. Use
          <code>DO_NOT_YIELD</code> if you want the scheduler to continue processing immediately as
        long as new events are available for processing. The <code>YIELD_AFTER_TRANSACTION</code>
        policy will tell the scheduler to reschedule the next batch for processing when a thread is
        available.</para>
      <para>You can set the maximum number of events to handle within a transaction using
          <code>setMaxTransactionSize(int)</code>. The default of this value is the number of events
        ready for processing at the moment the transaction started.</para>
      <simplesect>
        <title>Manipulating transactions during event processing</title>
      </simplesect>
      <para>You can change transaction semantics event during event processing. This can be done in
        one of two ways, depending on the type of event handler you use.</para>
      <para>If you use the <code>@EventHandler</code> annotation to mark event handler methods, you
        may use a second parameter of type <code>TransactionStatus</code>. If such parameter is
        available on the annotated method, the current <code>TransactionStatus</code> object is
        passed as a parameter.</para>
      <para>Alternatively, you can use the static <code>TransactionStatus.current()</code> accessor
        to gain access to the status of the current transaction.</para>
      <para>With the current transaction status, you can use the
          <code>requestImmediateYield()</code> and <code>requestImmediateCommit()</code> methods to
        end the transaction. The former will also tell the scheduler to reschedule the remainder of
        the events for another batch.</para>
    </sect2>
  </sect1>
  <sect1>
    <title xml:id="event-bus">Event Bus</title>
    <para>The <code>EventBus</code> is the mechanism that dispatches events to the event listeners.
      Axon Framework provides two implementations of the event bus:<code>AsyncEventBus</code> and
        <code>SynchronousEventBus.</code></para>
    <para>The <code>AsyncEventBus</code> is the default implementation of choice. It dispatches
      events asynchronously to all registered event listeners in the application. It uses an
        <code>EventSequencingPolicy</code> to define the sequential processing requirements of
      events. The <code>AsyncEventBus</code> can be configured with a <code>ExecutorService</code>
      implementation, providing maximum control of the number of processor threads.</para>
    <para>The <code>SynchronousEventBus</code> dispatches events in the same thread that publishes
      them. This is quite useful in test scenarios where the overhead of creating and managing
      application flow over multiple threads is unwanted.</para>
  </sect1>
</chapter>
