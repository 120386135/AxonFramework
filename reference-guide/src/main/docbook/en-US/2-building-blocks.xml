<?xml version="1.0" encoding="UTF-8"?>

<!--
  ~ Copyright (c) 2010. Axon Framework
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~     http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->
<chapter id="building-blocks" xmlns="http://docbook.org/ns/docbook">
  <title>Building Blocks</title>
  <figure>
    <title>Architecture overview of a CQRS application</title>
    <mediaobject>
      <imageobject>
        <info>Detailed architecture overview</info>
        <imagedata fileref="detailed-architecture-overview.png" width="300pt"/>
      </imageobject>
    </mediaobject>
  </figure>
  <sect1>
    <title xml:id="events">Events</title>
    <para>The Axon Framework makes a distinction between three types of events, each with a clear
      use and type of origin. Regardless of their type, all events must implement the
        <code>Event</code> interface or one of the more specific sub-types, each described in the
      sections below.</para>
    <sect2>
      <title>Domain Events</title>
      <para>The most important type of event in any CQRS application is the domain event. It
        represents an event that occurs inside your domain logic, such as a state change or special
        notification of a certain state. The latter not being per definition a state change.</para>
      <para>In the Axon Framework, all domain events should extend the abstract
          <code>DomainEvent</code> class. This abstract class keeps track of the aggregate they are
        generated by, and the sequence number of the event inside the aggregate. This information is
        important for the Event Sourcing mechanism, as well as for event handlers (see <xref
                  linkend="event-listeners"/>) that need to know the origin of an event.</para>
      <para>Although not enforced, it is good practice to make domain events immutable, preferably
        by making all fields final and by initializing the event within the constructor.</para>
      <note>
        <para>Although Domain Events technically indicate a state change, you should try to capture
          the intention of the state in the event, too. A good practice is to use an abstract
          implementation of a domain event to capture the fact that certain state has changed, and
          use a concrete sub-implementation of that abstract class that indicates the intention of
          the change. For example, you could have an abstract <code>OrderStatusChangedEvent</code>,
          and two implementations <code>OrderCancelledByUser</code> and
            <code>OrderCancelledByAdministrator</code> that capture the intent of the state change.
          Some listeners will care about the intent (e.g. to select a mail template when notifying
          the customer), while others don't (e.g. database updating event listeners). The latter
          will listen to events of the abstract type, while the former will listen to the concrete
          subtypes.</para>
      </note>
    </sect2>
    <sect2>
      <title>Application Events</title>
      <para>Application events are events that cannot be categorized as domain events, but do have a
        significant importance for the application. When using application events, you should always
        consider the fact that you might have overlooked an type of domain event. Examples of
        application events could be the expiry of a user session, an event reporting the successful
        sending of an email or a validation error on a command. The usefulness of these event depend
        on the type of application you are creating.</para>
      <para>In the Axon Framework, you can extend the abtract <code>ApplicationEvent</code> class
        for application events. This class will generate a unique identifier and a time stamp for
        the current event. Optionally, you can attach a class that acts as the source of the event.
        This source is loosely attached, which means that if the garbage collector cleans up the
        source, or when the event is serialized and deserialized, the original source class is not
        available anymore. Instead, you will have access to the type of source and the value of it's
          <code>toString()</code> method.</para>
    </sect2>
    <sect2>
      <title>System Events</title>
      <para>The third type of event identified by Axon Framework is the System Event. These events
        typically provide notifications of the status of the system. These events could, for
        example, indicate that a subsystem is non-responsive or has raised an exception.</para>
      <para>System events extends the abstract <code>SystemEvent</code> class. Upon construction of
        this event, you may pass an exception, defining the cause of the event, and a source object
        which is considered the source of the event. This object is loosely referenced from the
        event, which means that if the garbage collector cleans up the source, or when the event is
        serialized and deserialized, the original source class is not available anymore. Instead,
        you will have access to the type of source and the value of it's <code>toString()</code>
        method.</para>
    </sect2>
  </sect1>
  <sect1>
    <title>Aggregate</title>
    <para>An Aggregate is an entity or group of entities that is always kept in a consistent state.
      The aggregate root is the object on top of the aggregate tree that is responsible for
      maintaining this consistent state. </para>
    <para>For example, an "Order" aggregate will contain two entities: order and order item. To keep
      the entire aggregate in a consistent state, adding an order item should be done via the order
      entity. In this case, the order entity is the appointed aggregate root. For example, an
      "Order" aggregate will contain two entities: order and order item. To keep the entire
      aggregate in a consistent state, adding an order item should be done via the order entity. In
      this case, the order entity is the appointed aggregate root.</para>
    <sect2>
      <title>Basic aggregate implementations</title>
      <simplesect>
        <title><code xmlns="http://docbook.org/ns/docbook">AggregateRoot</code></title>
        <para>In Axon, all aggregate roots must implement the <code>AggregateRoot</code> interface.
          This interface describes that basic operations needed by the Repository to store and
          publish the generated domain events. There are, however, a number of abstract
          implementations that provide basic functionality.</para>
        <note>
          <para>Note that only the aggregate root needs to implement the AggregateRoot interface or
            implement one of the abstract classes mentioned below. The other entities that are part
            of the aggregate do not have to implement any interfaces.</para>
        </note>
      </simplesect>
      <simplesect>
        <title><code>VersionedAggregateRoot</code></title>
        <para>The <code>VersionedAggregateRoot</code> interface provides the information needed by
          repositories to perform optimistic locking. The only method added to the
            <code>AggregateRoot</code> interface is
          <code>getLastCommittedEventSequenceNumber</code>, which returns the sequence number of the
          event that was last committed.</para>
        <para>See <xref linkend="locking-repository"/> for more information about the abstract
            <code>LockingRepository</code> implementation.</para>
      </simplesect>
      <simplesect>
        <title><code>AbstractAggregateRoot</code></title>
        <para>The <code>AbstractAggregateRoot</code> is a basic implementation that requires you to
          override the handle method to implement the state change logic. This abstract class
          provides an apply method that you can call in your business logic method to have an event
          applied. The <code>AbstractAggregateRoot</code> will keep track of all uncommitted applied
          events and make sure they are forwarded to the event bus when the aggregate is saved to a
          repository.</para>
      </simplesect>
    </sect2>
    <sect2>
      <title>Event sourcing aggregates</title>
      <para>Axon framework provides a few repository implementations that can use event sourcing as
        storage method for aggregates. These repositories require that aggregates implement the
          <code>EventSourcedAggregateRoot</code> interface. As with most interfaces in Axon, we also
        provide one or more abstract implementation to help you on your way.</para>
      <simplesect>
        <title><code>EventSourcedAggregateRoot</code></title>
        <para>The <code>EventSourcedAggregateRoot</code> provides an extra method on top of the
            <code>VersionedAggregateRoot</code>: <code>initializeState()</code>. This method allows
          a repository to initialize the aggregate's state based on an event stream.</para>
      </simplesect>
      <simplesect>
        <title><code>AbstractEventSourcedAggregateRoot</code></title>
        <para>The <code>AbstractEventSourcedAggregateRoot</code> implements all methods on the
            <code>EventSourcedAggregateRoot</code> interface. All you need to implement is the
            <code>handle()</code> method, which contains the actual logic to change state based on
          information in the events. When you extend the
            <code>AbstractEventSourcedAggregateRoot</code>, you can register new events using the
            <code>apply()</code> method. This method will register the event to be committed when
          the aggregate is saved, and will call the <code>handle()</code> method with the event as
          parameter.</para>
        <programlisting language="java">public class MyAggregateRoot extends AbstractEventSourcedAggregateRoot {
  private String someProperty;

  public MyAggregateRoot() {
    apply(new MyAggregateCreatedEvent());
  }

  public MyAggregateRoot(UUID identifier) {
    super(identifier);
  }

  public void handle(DomainEvent event) {
    if (event instanceof MyAggregateCreatedEvent) {
      // do something with someProperty
    }
    // and more if-else-if logic here
  }
}</programlisting>
      </simplesect>
      <simplesect>
        <title><code xml:id="annotated-aggregate-root">AbstractAnnotatedAggregateRoot</code></title>
        <para>As you see, the implementation of the <code>handle()</code> method can become quite
          verbose and hard to read. The <code>AbstractAnnotatedAggregateRoot</code> can help. The
            <code>AbstractAnnotatedAggregateRoot</code> is a specialization of the
            <code>AbstractAggregateRoot</code> that provides <code>@EventHandler</code> annotation
          support to your aggregate. Instead of a single <code>handle()</code> method, you can split
          the logic in separate methods, with names that you may define yourself. Just annotate the
          event handler methods with <code>@EventHandler</code>, and the
            <code>AbstractAnnotatedAggregateRoot</code> will invoke the right method for you.</para>
        <programlisting language="java">public class MyAggregateRoot extends AbstractEventSourcedAggregateRoot {
  private String someProperty;

  public MyAggregateRoot() {
    apply(new MyAggregateCreatedEvent());
  }

  public MyAggregateRoot(UUID identifier) {
    super(identifier);
  }

  @EventHandler
  private void handleMyAggregateCreatedEvent(MyAggregateCreatedEvent event) {
      // do something with someProperty
  }
}</programlisting>
        <para>In all circumstances, exactly one single event handler method is invoked. The
            <code>AbstractAnnotatedAggregateRoot</code> will search the most specific method to
          invoke, in the following order:</para>
        <orderedlist>
          <listitem>
            <para>On the actual instance level of the class hierarchy (as returned by
                <code>this.getClass()</code>), all annotated methods are evaluated</para>
          </listitem>
          <listitem>
            <para>If one or methods are found of which the parameter is of the event type or a super
              type, the method with the most specific class (the subclass) is chosen and
              invoked</para>
          </listitem>
          <listitem>
            <para>If no methods are found on this level of the class hierarchy, the super type is
              evaluated the same way</para>
          </listitem>
          <listitem>
            <para>When the level of the <code>AbstractAnnotatedAggregateRoot</code> is reached, and
              no suitable event handler is found, an <code>UnhandledEventException</code> is
              thrown.</para>
          </listitem>
        </orderedlist>
        <para>Event handler methods may be private, as long as the security settings of the JVM
          allow the Axon Framework to change the accessibility of the method. This allows you to
          clearly separate the public API of your aggregate, which exposes the methods that generate
          events, from the internal logic, which processes the events.</para>
        <tip>
          <para>If you have some events that have no direct effect on any fields in the aggregate,
            you can choose to create a <code>handleOtherEvents(DomainEvent event)</code> method with
            an empty body. This will prevent any exception being thrown. Do consider, however, that
            doing so may result in unexpected behavior if an event handler for a specific type of
            event is forgotten.</para>
        </tip>
      </simplesect>
    </sect2>
  </sect1>
  <sect1 xml:id="event-listeners">
    <title xml:id="event-listeners">Event Listeners</title>
    <para linkend="">Event listeners are the component that act on incoming events. These events may
      be of any type of the events mentioned in <xref linkend="events"/>. In the Axon Framework, all
      event listenerrs must implement the <code>EventListener</code> interface. </para>
    <sect2>
      <title>Basic configuration</title>
      <para>Event listeners need to be registered with an event bus (see <xref linkend="event-bus"
              />) to be notified of events. Axon, however, provides a base implementation that take care
        of this, and other things, for you.</para>
      <simplesect>
        <title><code>AnnotationEventListenerAdapter</code></title>
        <para>The <code>AnnotationEventListenerAdapter</code> can wrap any bean into an event
          listener. The adapter will invoke the most appropriate event handler method available.
          These event handler methods must be annotated with the <code>@EventHandler</code>
          annotation and are resolved according to the same rules that count for annotated aggregate
          roots (see <xref linkend="annotated-aggregate-root"/>).</para>
      </simplesect>
      <para>If you use the annotation support features, you can use the
          <code>AnnotationEventListenerAdapter</code> (and subclasses) to turn your annotated pojo
        into a full blown event listener. See annotation support for more information.</para>
    </sect2>
    <sect2>
      <title>Concurrent processing of events</title>
      <para/>
    </sect2>
    <sect2>
      <title>Dealing with transactions</title>
    </sect2>
  </sect1>
  <sect1>
    <title xml:id="event-bus">Event Bus</title>
    <para>The <code>EventBus</code> is the mechanism that dispatches events to the event listeners.
      Axon Framework provides two implementations of the event bus:<code>AsyncEventBus</code> and
        <code>SynchronousEventBus.</code></para>
    <para>The <code>AsyncEventBus</code> is the default implementation of choice. It dispatches
      events asynchronously to all registered event listeners in the application. It uses an
        <code>EventSequencingPolicy</code> to define the sequential processing requirements of
      events. The <code>AsyncEventBus</code> can be configured with a <code>ExecutorService</code>
      implementation, providing maximum control of the number of processor threads.</para>
    <para>The <code>SynchronousEventBus</code> dispatches events in the same thread that publishes
      them. This is quite useful in test scenarios where the overhead of creating and managing
      application flow over multiple threads is unwanted.</para>
  </sect1>
</chapter>
