<?xml version="1.0" encoding="UTF-8"?>
<!--
  ~ Copyright (c) 2010. Axon Framework
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~     http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->
<chapter id="using-spring" xmlns="http://docbook.org/ns/docbook">
    <title>Using Spring</title>
    <para>The AxonFramework has many integration points with the Spring Framework. All major
        building blocks in Axon are Spring configurable. Furthermore, there are some Bean Post
        Processors that scan the application context for building blocks and automatically wires
        them.</para>
    <para>In addition, the Axon Framework makes use of Spring's Extensible Schema-based configuration feature to make Axon
        application configuration even easier. Axon Framework sports a Spring context configuration namespace of its own that
        allows you to create common configurations using Spring's XML configuration syntax, but in a more functionally
        expressive way than by wiring together explicit bean declarations.</para>

	<sect1>
		<title>Adding support for the Java Platform Common Annotations</title>
    	<para>Axon uses JSR 250 annotations (<code>@PostConstruct</code> and <code>@PreDestroy</code>)
        to annotate lifecycle methods of some of the building blocks. Spring doesn't always
        automatically evaluate these annotations. To force Spring to do so, add the
            <code>&lt;context:annotation-config/></code> tag to your application context, as shown
        in the example
        below:
        <programlisting language="xml">&lt;beans xmlns="http://www.springframework.org/schema/beans" 
       xmlns:context="http://www.springframework.org/schema/context">


    &lt;context:annotation-config/>

&lt;/beans></programlisting>
		</para>
	</sect1>
	
    <sect1>
		<title>Getting started with the Axon namespace</title>
			<para>As mentioned earlier, the Axon Framework provides a separate namespace full of elements that allow you to
				configure your Axon applications quickly when using Spring. In order to use this namespace you must first add the
				declaration for this namespace to your Spring XML configuration files.</para>
			<para>Assume you already have an XML configuration file like this:</para>
    
			<programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8"?>
			
&lt;beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">			
	
		...
               
&lt;/beans>
			</programlisting>
               
			<para>To modify this configuration file to use elements from the Axon namespace, just add the following declarations:</para>
               
			<programlistingco>
				<areaspec>
					<area coords="3 70" xml:id="ex.nmsp.decl"/>
					<area coords="5 118" xml:id="ex.nmsp.loc"/>
				</areaspec>

				<programlisting language="xml">&lt;beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:axon="http://www.axonframework.org/schema/axon-framework-1.0"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
	http://www.axonframework.org/schema/axon-framework-1.0 http://www.axonframework.org/schema/axon-framework-1.0.xsd">
				</programlisting>
                       
				<calloutlist>
					<callout arearefs="ex.nmsp.decl">
						<para>The declaration of the <code>axon</code> namespace reference that you will use through the configuration file.</para>
					</callout>
					<callout arearefs="ex.nmsp.loc">
						<para>Maps the Axon namespace to the XSD where the namespace is defined.</para>
					</callout>
				</calloutlist>
			</programlistingco>
	</sect1>
	
    <sect1>
        <title>Wiring event and command handlers</title>
        <sect2>
        <title>Event handlers</title>
        <para>Using the annotated event listeners is very easy when you use Spring. All you need to
            do is configure the <code>AnnotationEventListenerBeanPostProcessor</code> in your
            application context. This post processor will discover beans with <code>@EventHandler</code>
            annotated methods and automatically connect them to the event bus.<programlistingco>
                <areaspec>
                    <area xml:id="postprocessor-co" coords="3 67"/>
                    <area xml:id="optional-eventbus-reference-co" coords="4 52"/>
                    <area xml:id="eventlistener-co" coords="7 76"/>
                </areaspec>
                <programlisting language="xml">&lt;beans xmlns="http://www.springframework.org/schema/beans">

    &lt;bean class="org...AnnotationEventListenerBeanPostProcessor">
        &lt;property name="eventBus" ref="eventBus"/>
    &lt;/bean>

    &lt;bean class="org.axonframework.sample.app.query.AddressTableUpdater"/>

&lt;/beans></programlisting>
                <calloutlist>
                    <callout arearefs="postprocessor-co">
                        <para>This bean post processor will scan the application context for beans
                            with an <code>@EventHandler</code> annotated method.</para>
                    </callout>
                    <callout arearefs="optional-eventbus-reference-co">
                        <para>The reference to the event bus is optional, if only a single
                                <code>EventBus</code> implementation is configured in the
                            application context. The bean postprocessor will automatically find and
                            wire it. If there is more than one <code>EventBus</code> in the context,
                            you must specify the one to use in the postprocessor.</para>
                    </callout>
                    <callout arearefs="eventlistener-co">
                        <para>This event listener will be automatically recognized and subscribed to
                            the event bus.</para>
                    </callout>
                </calloutlist>
            </programlistingco></para>
        <para>You can also wire event listeners "manually", by explicitly defining them within a
                <code>AnnotationEventListenerAdapter</code> bean, as shown in the code sample below.<programlistingco>
                <areaspec>
                    <area xml:id="adapter-co" coords="3 82"/>
                    <area xml:id="eventbus-reference-co" coords="7 52"/>
                </areaspec>
                <programlisting language="xml">&lt;beans xmlns="http://www.springframework.org/schema/beans">

    &lt;bean class="org.axonframework...annotation.AnnotationEventListenerAdapter">
        &lt;constructor-arg>
            &lt;bean class="org.axonframework.sample.app.query.AddressTableUpdater"/>
        &lt;/constructor-arg>
        &lt;property name="eventBus" ref="eventBus"/>
    &lt;/bean>

&lt;/beans></programlisting>
                <calloutlist>
                    <callout arearefs="adapter-co">
                        <para>The adapter turns any bean with <code>@EventHandler</code> methods
                            into an <code>EventListener</code></para>
                    </callout>
                    <callout arearefs="eventbus-reference-co">
                        <para>You need to explicitly reference the event bus to which you like to
                            register the event listener</para>
                    </callout>
                </calloutlist>
            </programlistingco></para>
        <warning>
            <para>Be careful when wiring event listeners "manually" while there is also an
                    <code>AnnotationEventListenerBeanPostProcessor</code> in the application
                context. This will cause the event listener to be wired twice.</para>
        </warning>
        </sect2>
    
    	<sect2>
    		<title>Command handlers</title>
    		<para>Wiring command handlers is very much like wiring event handlers: there is an
			<code>AnnotationCommandHandlerBeanPostProcessor</code> which will automatically register 
			classes containing command handler methods (i.e. methods annotated with the
			<code>@CommandHandler</code> annotation) with a command bus.
			
			<programlistingco>
                <areaspec>
                    <area xml:id="commandpostprocessor-co" coords="3 68"/>
                    <area xml:id="optional-commandbus-reference-co" coords="4 56"/>
                    <area xml:id="commandhandler-co" coords="7 80"/>
                </areaspec>
                <programlisting language="xml">&lt;beans xmlns="http://www.springframework.org/schema/beans">

    &lt;bean class="org...AnnotationCommandHandlerBeanPostProcessor">
        &lt;property name="commandBus" ref="commandBus"/>
    &lt;/bean>

    &lt;bean class="org.axonframework.sample.app.command.ContactCommandHandler"/>

&lt;/beans></programlisting>
                <calloutlist>
                    <callout arearefs="commandpostprocessor-co">
                        <para>This bean post processor will scan the application context for beans
                            with a <code>@CommandHandler</code> annotated method.</para>
                    </callout>
                    <callout arearefs="optional-commandbus-reference-co">
                        <para>The reference to the command bus is optional, if only a single
                                <code>CommandBus</code> implementation is configured in the
                            application context. The bean postprocessor will automatically find and
                            wire it. If there is more than one <code>CommandBus</code> in the context,
                            you must specify the one to use in the postprocessor.</para>
                    </callout>
                    <callout arearefs="commandhandler-co">
                        <para>This command handler will be automatically recognized and subscribed to
                            the command bus.</para>
                    </callout>
                </calloutlist>
            </programlistingco></para>
            
            <para>As with event listeners, you can also wire command handlers "manually" by explicitly defining them within a
                <code>AnnotationCommandHandlerAdapter</code> bean, as shown in the code sample below.<programlistingco>
                <areaspec>
                    <area xml:id="commandadapter-co" coords="3 83"/>
                    <area xml:id="commandbus-reference-co" coords="7 56"/>
                </areaspec>
                <programlisting language="xml">&lt;beans xmlns="http://www.springframework.org/schema/beans">

    &lt;bean class="org.axonframework...annotation.AnnotationCommandHandlerAdapter">
        &lt;constructor-arg>
            &lt;bean class="org.axonframework.sample.app.command.ContactCommandHandler"/>
        &lt;/constructor-arg>
        &lt;property name="commandBus" ref="commandBus"/>
    &lt;/bean>

&lt;/beans></programlisting>
                <calloutlist>
                    <callout arearefs="commandadapter-co">
                        <para>The adapter turns any bean with <code>@EventHandler</code> methods
                            into an <code>EventListener</code></para>
                    </callout>
                    <callout arearefs="commandbus-reference-co">
                        <para>You need to explicitly reference the event bus to which you like to
                            register the event listener</para>
                    </callout>
                </calloutlist>
            </programlistingco></para>
        <warning>
            <para>Be careful when wiring command handlers "manually" while there is also an
                    <code>AnnotationCommandHandlerBeanPostProcessor</code> in the application
                context. This will cause the command handler to be wired twice.</para>
        </warning>
    	</sect2>
    
    	<sect2>
    		<title>Using the Axon namespace shortcut</title>
    		<para>
	The previous two sections explained how you wire bean post processors to activate annotation support for your command
	handlers and event listeners. Using support from the Axon namespace you can accomplish the same in one go, using the
	<code>annotation-configuration</code>
	element:
	
				<programlisting>&lt;axon:annotation-configuration /></programlisting></para>
				
			<para>The <code>annotation-configuration</code> element has the following attributes that allow you to configure annotation support further:</para>
			
			<table frame="all">
				<title>Attributes for annotation-configuration</title>
				<tgroup cols="4" colsep="1" rowsep="1" align="center">
					<thead style="bgcolor:black;color:white">
						<row>
							<entry>Attribute name</entry>
							<entry>Optional/Mandatory/Conditional</entry>
							<entry>Expected value type</entry>
							<entry>Description</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>commandBus</entry>
							<entry>Conditional</entry>
							<entry>Reference to a CommandBus Bean</entry>
							<entry>Needed only if the application context contains more than one command bus.</entry>
						</row>
						<row>
							<entry>eventBus</entry>
							<entry>Conditional</entry>
							<entry>Reference to an EventBus Bean</entry>
							<entry>Needed only if the application context contains more than one event bus.</entry>
						</row>
						<row>
							<entry>executor</entry>
							<entry>Optional</entry>
							<entry>Reference to a java.util.concurrent.Executor instance bean</entry>
							<entry>An executor to be used with asynchronous event listeners</entry>
						</row>
					</tbody>
				</tgroup>
			</table>
    	</sect2>
    </sect1>
    
    
    
    <sect1>
        <title>Wiring the event bus</title>
        <para>In a typical Axon application there is only one event bus. Wiring it is just a matter
            of creating a bean of a subtype of <code>EventBus</code>. The
                <code>SimpleEventBus</code> is the provided implementation.
            <programlisting language="xml">&lt;beans xmlns="http://www.springframework.org/schema/beans">

    &lt;bean id="eventBus" class="org.axonframework.eventhandling.SimpleEventBus"/>

&lt;/beans></programlisting></para>

		<para>Setting up an event bus can also be accomplished using support from the axon namespace:
		
			<programlisting language="xml">&lt;axon:eventBus id="eventBus"/></programlisting></para>

    </sect1>
    <sect1>
        <title>Wiring the command bus</title>
        <sect2>
        	<title>The basics</title>
	        <para>The command bus doesn't take any configuration to use. However, it allows you to
	            configure a number of interceptors that should take action based on each incoming
	            command.</para>
	        <para>
	            <programlisting language="xml">&lt;beans xmlns="http://www.springframework.org/schema/beans">

    &lt;bean id="eventBus" class="org.axonframework.commandhandling.CommandBus">
        &lt;property name="interceptors">
            &lt;list>
                &lt;bean class="org.axonframework...SpringTransactionalInterceptor">
                    &lt;property name="transactionManager" ref="transactionManager"/>
                &lt;/bean>
                &lt;bean class="other-interceptors"/>
            &lt;/list>
        &lt;/property>
    &lt;/bean>

&lt;/beans></programlisting>
        	</para>
        </sect2>
        <sect2>
        	<title>Using the Axon namespace</title>
        	<para>Setting up a basic command bus using the Axon namspace is a piece of cake: you can use the <code>commandBus</code> element:
        	
        		<programlisting language="xml">&lt;axon:commandBus id="commandBus"/></programlisting></para>
        		
        	<para>Configuring command interceptors for your command bus is also possible using the <code>commandBus</code> element. In fact, you have two options for this:
        		<orderedlist>
        			<listitem>
	        			<para>If you only want to use a single interceptor, the quickest way is to use the optional <code>interceptor</code> attribute like so:
	        				<programlisting language="xml">&lt;axon:commandBus id="commandBus" interceptor="commandbus-interceptor"/></programlisting>
	        			</para>
        			</listitem>
        			<listitem>
        				<para>If you want to set up an interceptor chain, you must use the nested <code>interceptors</code> element:
	        				<programlisting language="xml">&lt;axon:commandBus id="commandBus">
	&lt;axon:interceptors>
		&lt;ref>interceptor-zero&lt;/ref>
		&lt;ref>interceptor-one&lt;/ref>
		&lt;ref>interceptor-two&lt;/ref>
	&lt;/axon:interceptors>
&lt;/axon:commandBus>	        				
	        				</programlisting>
	        				Of course you are not limited to bean references; you can also include local bean definitions if you want.
	        			</para>
        			</listitem>
        		</orderedlist>
        		<warning>
        			<para>Don't try to use the <code>interceptors</code> element and the <code>interceptor</code> attribute at the same time. If the <code>interceptors</code> element is present, the attribute is ignored.</para>
        		</warning>
        	</para>
        	
        	<para>
	In case you aren't using annotation-based command handler configuration, you can configure your command bus with a map
	of command handler subscriptions. You do this using the
	<code>subscriptions</code>
	child element of
	<code>commandBus</code>
	, in which you then include a list of Spring-standard
	<code>entry</code>
	elements. You use the command type as the key and the handler as the value in each mapping.
	
				<programlistingco>
					<areaspec>
						<area coords="2 23" xml:id="ex.subscriptions.elt"/>
						<area coords="4 38" xml:id="ex.subscriptions.key"/>
						<area coords="5 45" xml:id="ex.subscriptions.val"/>
					</areaspec>
					<programlisting language="xml">&lt;axon:commandBus id="commandBus">
	&lt;axon:subscriptions>
		&lt;entry>
			&lt;key>org...MyExampleCommand&lt;/key>
			&lt;value>&lt;ref>commandHandler&lt;/ref>&lt;/value>
		&lt;/entry>
	&lt;/axon:subscriptions>
&lt;/axon:commandBus>
					</programlisting>
					
					<calloutlist>
						<callout arearefs="ex.subscriptions.elt">
							<para>The subscriptions element is used to set up a map of subscriptions.</para>
						</callout>
						<callout arearefs="ex.subscriptions.key">
							<para>The command class that a handler is to be subscribed to.</para>
						</callout>
						<callout arearefs="ex.subscriptions.val">
							<para>The command handler interested in the command type.</para>
						</callout>
					</calloutlist>
				</programlistingco>		
			</para>
        </sect2>
    </sect1>
    <sect1>
        <title>Wiring the Repository</title>
        <para>Wiring a repository is very similar to any other bean you would use in a Spring
            application. Axon only provides abstract implementations for repositories, which means
            you need to extend one of them. See <xref linkend="repositories-and-event-stores"/> for
            the available implementations.</para>
        <para>Repository implementations that do support event sourcing just need the event bus to
            be configured, as well as any dependencies that your own implementation has.
            <programlisting language="xml">&lt;bean id="simpleRepository" class="my.package.SimpleRepository">
    &lt;property name="eventBus" ref="eventBus"/>
&lt;/bean></programlisting></para>
        <para>Repositories that support event sourcing will also need an event store, which takes
            care of the actual storage and retrieval of events. The example below shows a repository
            configuration of a repository that extends the
            <code>EventSourcingRepository</code>.<programlisting language="xml">&lt;bean id="contactRepository" class="org.axonframework.sample.app.command.ContactRepository">
    &lt;property name="eventBus" ref="eventBus"/>
    &lt;property name="eventStore" ref="eventStore"/>
&lt;/bean></programlisting></para>
        <para>In many cases, you can use the <code>GenericEventSourcingRepository</code>. Below is
            an example of XML application context configuration to wire such a repository.</para>
        <para>
            <programlisting language="xml">&lt;bean id="myRepository" class="org.axonframework.eventsourcing.GenericEventSourcingRepository">
    &lt;constructor-arg value="fully.qualified.class.Name"/>
    &lt;property name="eventBus" ref="eventBus"/>
    &lt;property name="eventStore" ref="eventStore"/>
&lt;/bean></programlisting>
        </para>
        <para>The repository will delegate the storage of events to the configured
                <code>eventStore</code>, while these events are dispatched using the provided
                <code>eventBus</code>.</para>
    </sect1>
    <sect1>
        <title>Wiring the event store</title>
        <para>All event sourcing repositorties need an event store. Wiring the
                <code>JpaEventStore</code> and the <code>FileSystemEventStore</code> is very
            similar, but the <code>JpaEventStore</code> needs to run in a Spring managed
            transaction. Unless you use the <code>SpringTransactionalInterceptor</code> on your
            command bus, you need to declare the annotation-driven transaction-manager as shown in
            the sample below.</para>
        <para>
            <programlisting language="xml">&lt;bean id="eventStore" class="org.axonframework.eventstore.jpa.JpaEventStore"/>

&lt;!-- enable the configuration of transactional behavior based on annotations -->
&lt;tx:annotation-driven transaction-manager="txManager"/>

&lt;!-- declare transaction manager, data source, EntityManagerFactoryBean, etc --></programlisting>
        </para>
        
        <sect2>
        	<title>Event stores using the Axon namespace</title>
        	<para>Using the Axon namespace support, you can quickly configure event stores backed either by the file system or a JPA layer using the <code>eventStore</code> element:
        		<programlisting language="xml">&lt;axon:eventStore id="eventStore" type="JPA"/></programlisting>
        	</para>
        	
        	<para>The <code>eventStore</code> element has several configuration options, accessible through a number of attributes:
        	
        		<table frame="all">
        			<title>Attributes of the eventStore element</title>
        			<tgroup cols="4" colsep="1" rowsep="1" align="center">
						<thead style="bgcolor:black;color:white">
							<row>
								<entry>Attribute name</entry>
								<entry>Optional/Mandatory/Conditional</entry>
								<entry>Expected value type</entry>
								<entry>Description</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>id</entry>
								<entry>Mandatory</entry>
								<entry>String</entry>
								<entry>Spring bean id.</entry>
							</row>
							<row>
								<entry>type</entry>
								<entry>Mandatory</entry>
								<entry>"JPA" or "FILE"</entry>
								<entry>Determines whether the event store will be backed by the file system or a JPA datasource.</entry>
							</row>
							<row>
								<entry>entityManager</entry>
								<entry>Optional</entry>
								<entry>Bean reference</entry>
								<entry>Reference to a JPA entity manager, for JPA-based event stores; you can leave this off and let the system go through the platform EntityManagerFactory.</entry>
							</row>
							<row>
								<entry>baseDir</entry>
								<entry>Conditional</entry>
								<entry>String</entry>
								<entry>The name of the directory used for the event store file(s). Mandatory if the <code>type</code> attribute is set to "FILE"</entry>
							</row>
							<row>
								<entry>eventSerializer</entry>
								<entry>Optional</entry>
								<entry>Bean reference</entry>
								<entry>Reference to a helper bean that serializes events.</entry>
							</row>
						</tbody>
					</tgroup>
        		</table>
        	</para>
        </sect2>
        
    </sect1>
    <sect1>
        <title>Configuring Snapshotting</title>
        <para>Configuring snapshotting using Spring is not complex, but does require a number of
            beans to be configured in your application context.</para>
        <para>The <code>EventCountSnapshotterTrigger</code> needs to be configured as a proxy for
            your event store. That means all repositories should load and save aggregate from the
                <code>EventCountSnapshotterTrigger</code>, instead of the acutal event store.</para>
        <programlisting language="xml">&lt;bean id="triggeringEventStore" class="org.axonframework.eventsourcing.EventCountSnapshotterTrigger">
    &lt;property name="eventStore" ref="eventStore"/>
    &lt;property name="snapshotter" ref="snapshotter"/>
    &lt;property name="triggerConfiguration">
        &lt;props>
            &lt;prop key="Contact">20&lt;/prop>
        &lt;/props>
    &lt;/property>
&lt;/bean></programlisting>
        <para>The sample above configures an EventCountSnapshotter trigger that will trigger
            Snapshot creation for a Contact when 20 or more events are required to reload its
            current state. Any other aggregate type will revert to the default, which is 50 unless
            defined otherwise.</para>
        <para>The snapshotter is configured as follows:</para>
        <programlisting language="xml">&lt;bean id="snapshotter" class="org.axonframework.eventsourcing.SpringAggregateSnapshotter">
    &lt;property name="eventStore" ref="eventStore"/>
    &lt;property name="executor" ref="taskExecutor"/>
&lt;/bean>

&lt;bean id="taskExecutor" class="org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor">
    &lt;property name="corePoolSize" value="2"/>
    &lt;property name="maxPoolSize" value="5"/>
    &lt;property name="waitForTasksToCompleteOnShutdown" value="true"/>
&lt;/bean></programlisting>
        <para>In this sample, a <code>SpringAggregateSnapshotter</code> is used. This snapshotter
            will automatically detect any <code>PlatformTransactionManager</code> in your
            application context, as well as <code>AggregateFactory</code> instances, which all
            repositories typically are. That means you only need very little configuration to use a
                <code>Snapshotter</code> within Spring.</para>
    </sect1>
</chapter>
