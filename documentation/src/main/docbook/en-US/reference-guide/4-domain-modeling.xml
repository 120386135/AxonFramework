<?xml version="1.0" encoding="UTF-8"?>
<!--
    ~ Copyright (c) 2010. Axon Framework
    ~
    ~ Licensed under the Apache License, Version 2.0 (the "License");
    ~ you may not use this file except in compliance with the License.
    ~ You may obtain a copy of the License at
    ~
    ~     http://www.apache.org/licenses/LICENSE-2.0
    ~
    ~ Unless required by applicable law or agreed to in writing, software
    ~ distributed under the License is distributed on an "AS IS" BASIS,
    ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    ~ See the License for the specific language governing permissions and
    ~ limitations under the License.
-->
<chapter id="domain-modeling" xmlns="http://docbook.org/ns/docbook">
    <title>Domain Modeling</title>
    <para>In a CQRS-based application, a Domain Model (as defined by Eric Evans and Martin Fowler)
        can be a very powerful mechanism to harness the complexity involved in the validation and
        execution of state changes. Although a typical Domain Model has a great number of building
        blocks, two of them play a major role when applied to CQRS: the Event and the
        Aggregate.</para>
    <para>The following sections will explain the role of these building blocks and how to implement
        them using the Axon Framework.</para>
    <sect1 xml:id="events">
        <title>Events</title>
        <para>The Axon Framework makes a distinction between three types of events, each with a
            clear use and type of origin. Regardless of their type, all events must implement the
            <code>Event</code>
            interface or one of the more specific sub-types, Domain Events,
            Application Events and System Events, each described in the sections below.
        </para>
        <sect2 xml:id="domain-events">
            <title>Domain Events</title>
            <para>The most important type of event in any CQRS application is the domain event. It
                represents an event that occurs inside your domain logic, such as a state change or
                special notification of a certain state. The latter not being per definition a state
                change. </para>
            <para>In the Axon Framework, all domain events should extend the abstract
                    <code>DomainEvent</code> class. This abstract class keeps track of the aggregate
                they are generated by, and the sequence number of the event inside the aggregate.
                This information is important for the Event Sourcing mechanism, as well as for event
                handlers (see <xref linkend="event-listeners"/>) that need to know the origin of an
                event. </para>
            <para>Although not enforced, it is good practice to make domain events immutable,
                preferably by making all fields final and by initializing the event within the
                constructor. </para>
            <note>
                <para>Although Domain Events technically indicate a state change, you should try to
                    capture the intention of the state in the event, too. A good practice is to use
                    an abstract implementation of a domain event to capture the fact that certain
                    state has changed, and use a concrete sub-implementation of that abstract class
                    that indicates the intention of the change. For example, you could have an
                    abstract <code>AddressChangedEvent</code>, and two implementations
                        <code>ContactMovedEvent</code> and <code>AddressCorrectedEvent</code> that
                    capture the intent of the state change. Some listeners will care about the
                    intent (e.g. to send an address change confirmation email to the customer),
                    while others don't (e.g. database updating event listeners). The latter will
                    listen to events of the abstract type, while the former will listen to the
                    concrete subtypes. </para>
                <figure>
                    <title>Adding intent to events</title>
                    <mediaobject>
                        <info>Adding intent to events</info>
                        <imageobject role="fo">
                            <imagedata format="png" fileref="state-change-intent-hires.png"
                                width="10cm"/>
                        </imageobject>
                        <imageobject role="html">
                            <imagedata format="png" fileref="state-change-intent.png"/>
                        </imageobject>
                    </mediaobject>
                </figure>
            </note>
            <para>There is a special type of <code>DomainEvent</code>, which has a special meaning:
                    the<code>AggregateDeletedEvent</code>. This event can be extended to indicate
                that the event indicates a migration to a "deleted" state of the aggregate.
                Repositories must consider aggregates that have applied such an event as deleted.
                Loading such an aggregate in again results in an exception.</para>
            <para>Snapshot events are instances of <code>DomainEvent</code> with a special intent.
                They are typically not dispatched via the event bus, but are used to summarize an
                arbitrary number of events from the past into a single entry. This can drastically
                improve performance when initializing an aggregate's state from a series of events.
                See <xref linkend="using-snapshot-events"/> for more information about snapshot
                events and their use.</para>
            <simplesect>
                <title>Correlating and auditing</title>
                <para>If you wish to attach correlation identifiers and principal name (i.e. the
                    username of the user executing the current thread) to your domain events,
                    consider extending the <code>AuditedDomainEvent</code>. It will use the current
                    auditing context (see <xref linkend="auditing-interceptor"/>) to obtain this
                    information.</para>
            </simplesect>
        </sect2>
        <sect2>
            <title>Application Events</title>
            <para>Application events are events that cannot be categorized as domain events, but do
                have a significant importance for the application. When using application events,
                check if the event is actually a domain event that you over looked. Examples of
                application events are the expiry of a user session, or the notification of an email
                being successfully send. The usefulness of these events depend on the type of
                application you are creating.
            </para>
            <para>In the Axon Framework, you can extend the abtract
                <code>ApplicationEvent</code>
                class for application events. This class will generate a unique identifier and a
                time stamp for the current event. Optionally, you can attach an object that acts as
                the source of the event. This source is loosely attached, which means that if the
                garbage collector cleans up the source, or when the event is serialized and
                deserialized, the original source class is not available anymore. Instead, you will
                have access to the type of source and the value of it's
                <code>toString()</code>
                method.
            </para>
        </sect2>
        <sect2>
            <title>System Events</title>
            <para>The third type of event identified by Axon Framework is the System Event. These
                events typically provide notifications of the status of the system. These events
                could, for example, indicate that a subsystem is non-responsive or has raised an
                exception.
            </para>
            <para>All system events extend the abstract
                <code>SystemEvent</code>
                class. Upon
                construction of this event, you may pass an exception, defining the cause of the
                event, and a source object which is considered the source of the event. This object
                is loosely referenced from the event.
            </para>
        </sect2>
    </sect1>
    <sect1>
        <title>Aggregate</title>
        <para>An Aggregate is an entity or group of entities that is always kept in a consistent
            state. The aggregate root is the object on top of the aggregate tree that is responsible
            for maintaining this consistent state.
        </para>
        <note>
            <para>The term "Aggregate" refers to the aggregate as defined by Evans in Domain Driven
                Design: </para>
            <para>
                <quote>A cluster of associated objects that are treated as a unit for the purpose of
                    data changes. External references are restricted to one member of the Aggregate,
                    designated as the root. A set of consistency rules applies within the
                    Aggregate's boundaries. </quote>
            </para>
            <para>A more extensive definition can be found on: <link
                    xmlns:ns1="http://www.w3.org/1999/xlink"
                    ns1:href="http://domaindrivendesign.org/freelinking/Aggregate"
                    >http://domaindrivendesign.org/freelinking/Aggregate</link>. </para>
        </note>
        <para>For example, a "Contact" aggregate will contain two entities: contact and address. To
            keep the entire aggregate in a consistent state, adding an address to a contact should
            be done via the contact entity. In this case, the Contact entity is the appointed
            aggregate root.
        </para>
        <sect2>
            <title>Basic aggregate implementations</title>
            <simplesect>
                <title>
                    <code xmlns="http://docbook.org/ns/docbook">AggregateRoot</code>
                </title>
                <para>In Axon, all aggregate roots must implement the <code>AggregateRoot</code>
                    interface. This interface describes the basic operations needed by the
                    Repository to store and publish the generated domain events. However, Axon
                    Framework provides a number of abstract implementations that help you writing
                    your own aggregates. </para>
                <note>
                    <para>Note that only the aggregate root needs to implement the AggregateRoot
                        interface or implement one of the abstract classes mentioned below. The
                        other entities that are part of the aggregate do not have to implement any
                        interfaces.
                    </para>
                </note>
            </simplesect>
            <simplesect>
                <title>
                    <code>AbstractAggregateRoot</code>
                </title>
                <para>The
                    <code>AbstractAggregateRoot</code>
                    is a basic implementation that provides
                    a
                    <code>registerEvent(DomainEvent)</code>
                    method that you can call in your
                    business logic method to have an event added to the list of uncommitted events.
                    The
                    <code>AbstractAggregateRoot</code>
                    will keep track of all uncommitted
                    registered events and make sure they are forwarded to the event bus when the
                    aggregate is saved to a repository.
                </para>
            </simplesect>
        </sect2>
        <sect2>
            <title>Event sourcing aggregates</title>
            <para>Axon framework provides a few repository implementations that can use event
                sourcing as storage method for aggregates. These repositories require that
                aggregates implement the
                <code>EventSourcedAggregateRoot</code>
                interface. As with
                most interfaces in Axon, we also provide one or more abstract implementation to help
                you on your way.
            </para>
            <simplesect>
                <title>
                    <code>EventSourcedAggregateRoot</code>
                </title>
                <para>The
                    <code>EventSourcedAggregateRoot</code>
                    defines an extra method,
                    <code>initializeState()</code>, on top of the
                    <code>AggregateRoot</code>
                    interface. This method initializes an
                    aggregate's state based on an event stream.
                </para>
            </simplesect>
            <simplesect>
                <title>
                    <code>AbstractEventSourcedAggregateRoot</code>
                </title>
                <para>The
                    <code>AbstractEventSourcedAggregateRoot</code>
                    implements all methods on
                    the
                    <code>EventSourcedAggregateRoot</code>
                    interface. It defines an abstract
                    <code>handle()</code>
                    method, which you need to implement with the actual
                    logic to apply state changes based on domain events. When you extend the
                    <code>AbstractEventSourcedAggregateRoot</code>, you can register new events
                    using the
                    <code>apply()</code>
                    method. This method will register the event to be
                    committed when the aggregate is saved, and will call the
                    <code>handle()</code>
                    method with the event as parameter.
                </para>
                <programlisting language="java">public class MyAggregateRoot extends AbstractEventSourcedAggregateRoot {

    private String someProperty;

    public MyAggregateRoot() {
        apply(new MyAggregateCreatedEvent());
    }

    public MyAggregateRoot(UUID identifier) {
        super(identifier);
    }

    public void handle(DomainEvent event) {
        if (event instanceof MyAggregateCreatedEvent) {
            // do something with someProperty
        }
        // and more if-else-if logic here
    }
}                </programlisting>
            </simplesect>
            <simplesect xml:id="annotated-aggregate-root">
                <title>
                    <code>AbstractAnnotatedAggregateRoot</code>
                </title>
                <para>As you see in the example above, the implementation of the
                    <code>handle()</code>
                    method can become quite verbose and hard to read. The
                    <code>AbstractAnnotatedAggregateRoot</code>
                    can help. The
                    <code>AbstractAnnotatedAggregateRoot</code>
                    is a specialization of the
                    <code>AbstractAggregateRoot</code>
                    that provides
                    <code>@EventHandler</code>
                    annotation support to your aggregate. Instead of a single
                    <code>handle()</code>
                    method, you can split the logic in separate methods, with names that you may
                    define yourself. Just annotate the event handler methods with
                    <code>@EventHandler</code>, and the
                    <code>AbstractAnnotatedAggregateRoot</code>
                    will invoke the right method for
                    you.
                </para>
                <programlisting language="java">public class MyAggregateRoot extends AbstractEventSourcedAggregateRoot {
    private String someProperty;

    public MyAggregateRoot() {
        apply(new MyAggregateCreatedEvent());
    }

    public MyAggregateRoot(UUID identifier) {
        super(identifier);
    }

    @EventHandler
    private void handleMyAggregateCreatedEvent(MyAggregateCreatedEvent event) {
        // do something with someProperty
    }
}                </programlisting>
                <para>In all circumstances, exactly one event handler method is invoked. The
                    <code>AbstractAnnotatedAggregateRoot</code>
                    will search the most specific
                    method to invoke, in the following order:
                </para>
                <orderedlist>
                    <listitem>
                        <para>On the actual instance level of the class hierarchy (as returned by
                            <code>this.getClass()</code>), all annotated methods are evaluated
                        </para>
                    </listitem>
                    <listitem>
                        <para>If one or more methods are found of which the parameter is of the
                            event type or a super type, the method with the most specific class (the
                            subclass) is chosen and invoked
                        </para>
                    </listitem>
                    <listitem>
                        <para>If no methods are found on this level of the class hierarchy, the
                            super type is evaluated the same way
                        </para>
                    </listitem>
                    <listitem>
                        <para>When the level of the
                            <code>AbstractAnnotatedAggregateRoot</code>
                            is
                            reached, and no suitable event handler is found, an
                            <code>UnhandledEventException</code>
                            is thrown.
                        </para>
                    </listitem>
                </orderedlist>
                <para>Event handler methods may be private, as long as the security settings of the
                    JVM allow the Axon Framework to change the accessibility of the method. This
                    allows you to clearly separate the public API of your aggregate, which exposes
                    the methods that generate events, from the internal logic, which processes the
                    events.
                </para>
                <tip>
                    <para>An Aggregate will only contain fields of properties it uses for validation
                        or business logic decisions. That means you will likely have some events
                        that have no direct effect on any fields in the aggregate. In that case you
                        can choose to create a
                        <code>handleOtherEvents(DomainEvent event)</code>
                        method with an empty body. This handler will be called for any event for
                        which there is no specific handler, preventing any exception being thrown.
                        Do consider, however, that doing so may result in unexpected behavior if an
                        event handler for a specific type of event is forgotten.
                    </para>
                </tip>
            </simplesect>
        </sect2>
    </sect1>
       
</chapter>
