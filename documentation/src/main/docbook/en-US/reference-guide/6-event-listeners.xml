<?xml version="1.0" encoding="UTF-8"?>
<!--
  ~ Copyright (c) 2010-2012. Axon Framework
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~     http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->
<chapter xml:id="event-processing" version="5.0" xmlns="http://docbook.org/ns/docbook">
    <title>Event Processing</title>
    <para>The Events generated by the application need to be dispatched to the components that
        update the query databases, search engines or any other resources that need them: the Event
        Listeners. This is the responsibility of the Event Bus. Axon Framework provides an Event Bus
        and some base classes to help you implement Event Listeners.</para>
    <sect1 xml:id="event-bus">
        <title>Event Bus</title>
        <para>The <code>EventBus</code> is the mechanism that dispatches events to the subscribed
            event listeners. Axon Framework provides two implementation of the event bus:
                <code>SimpleEventBus</code> and <code>ClusteringEventBus</code>. Both
            implementations manage subscribed <code>EventListeners</code> and forward all incoming
            events to all subscribed listeners. This means that Event Listeners must be explicitly
            registered with the Event Bus in order for them to receive events. The registration
            process is thread safe. Listeners may register and unregister for events at any
            time.</para>
        <sect2>
            <title>Simple Event Bus</title>
            <para>The <code>SimpleEventBus</code> is, as the name suggests, a very basic
                implementation of the <code>EventBus</code> interface. It just dispatches each
                incoming <code>Event</code> to each of the subscribed <code>EventListeners</code>
                sequentially. If an EventListener throws an <code>Exception</code>, dispatching
                stops and the exception is propagated to the component publising the
                    <code>Event</code>.</para>
            <para>The <code>SimpleEventBus</code> is suitable for most cases where dispatching is
                done synchronously and locally, (i.e. in a single JVM). Once you application
                requires <code>Events</code> to be published across multiple JVMs, you could
                consider using the <code>ClusteringEventBus</code> instead.</para>
        </sect2>
        <sect2>
            <title>Clustering Event Bus</title>
            <para>The <code>ClusteringEventsBus</code> allows application developers to bundle
                    <code>EventListener</code>s into <code>Cluster</code>s based on their properties
                and non-functional requirements. The ClusteringEventBus is also more capable to deal
                with Events being dispatched among different machines.</para>
            <para><!--TODO: Add schema of Clustering Event Bus--></para>
            <para>The ClusteringEventsBus contains two mechanisms: the <code>ClusterSelector</code>,
                which selects a <code>Cluster</code> instance for each of the registered
                    <code>EventListener</code>s, and the <code>EventBusTerminal</code>, which is
                responsible for dispatching Events to each of the relevant clusters.</para>
            <note>
                <title>Background: Axon Terminal</title>
                <para>In the nervous system, an Axon (one of the components of a Neuron) transports
                    electrical signals. These Neurons are interconnected in very complex
                    arrangements. The Axon Terminal is responsible for transmitting these signals
                    from one Neuron to another.</para>
                <para>More information: <link xmlns:xlink="http://www.w3.org/1999/xlink"
                        xlink:href="www.wikipedia.org/wiki/Axon_terminal"
                        >www.wikipedia.org/wiki/Axon_terminal</link>.</para>
            </note>
            <simplesect>
                <title><code>ClusterSelector</code></title>
                <para>The primary responsibility of the <code>ClusterSelector</code> is to, as the
                    name suggests, select a cluster for each Event Listener that subscribes to the
                    Event Bus. By default, all Event Listeners are placed in a single Cluster
                    instance, which dispatches events to its members sequentially and in the calling
                    thread (similar to how the <code>SimpleEventBus</code> works). By providing a
                    custom implementation, you can arrange the Event Listeners into different
                    Cluster instances to suit the requirements of your architecture.</para>
                <para>A number of <code>ClusterSelector</code> implementations are available. The
                        <code>ClassNamePrefixClusterSelector</code>, for example, uses a mapping of
                    package prefixes to decide which cluster is (most) suitable for an Event
                    Listener. Similarly, the <code>ClassNamePatternClusterSelector</code> uses
                    pattern matching to decide whether a given cluster is suitable. You can use the
                        <code>CompositeClusterSelector</code> to combine several cluster selectors
                    into a single one.</para>
                <para>At this moment, there is a single implementation of the <code>Cluster</code>
                    interface: <code>SimpleCluster</code>. This implementation calls each
                    EventListener sequentially in the calling thread. By adding information in the
                    Meta Data of a cluster, the selector can provide hints to the Terminal about the
                    expected behavior.</para>
                <note>
                    <title>Clusters and Cluster Selectors in Spring</title>
                    <para>Spring users can define clusters using the &lt;cluster> element. This
                        element allows you to define the selection criteria for Event Handlers in
                        that cluster. These criteria are transformed into cluster selectors and used
                        to assign each Listener to one of the clusters.</para>
                </note>
            </simplesect>
            <simplesect>
                <title><code>EventBusTerminal</code></title>
                <para>The <code>EventBusTerminal</code> forms the bridge between the Clusters inside
                    the Event Bus. While some terminals will dispatch within the same JVM, others
                    are aware of remoting technologies, such as AMQP to dispatch Event Messages to
                    clusters on remote machines. The default implementation dispatches published
                    events to each of the (local) clusters using the publishing thread. This means
                    that with the default terminal, and the default <code>ClusterSelector</code>,
                    the behavior of the <code>ClusteringEventBus</code> is exactly the same as that
                    of the <code>SimpleEventBus</code>.</para>
                <para>In a typical AMQP based configuration, the <code>EventBusTerminal</code> would
                    send published events to an Exchange. For each cluster, a Queue would be
                    connected to that exchange. The <code>EventBusTerminal</code> will create a
                    consumer for each cluster, which reads from its related Queue and forwards each
                    message to that cluster. Event Listeners in a distributed environment where at
                    most one instance should receive an Events should be placed in a separate
                    cluster, which competes with the other instances on a single Queue.</para>
            </simplesect>
        </sect2>
    </sect1>
    <sect1 xml:id="event-listeners">
        <title>Event Listeners</title>
        <para>Event listeners are the component that act on incoming events. Events may be of any
            type. In the Axon Framework, all event listeners must implement the
                <code>EventListener</code> interface. </para>
        <sect2>
            <title>Basic implementation</title>
            <para>Event listeners need to be registered with an event bus (see <xref
                    linkend="event-bus"/>) to be notified of events. The EventListener interface
                prescribes a single method to be implemented. This method is invoked for each Event
                Message passed on the Event Bus that it is subscribed
                to:<programlisting language="java">public class MyEventListener implement EventListener {

    public void handle(EventMessage message) {
        if (SomeEvent.class.isAssignableFrom(message.getPayloadType) {
            // handle SomeEvent
        } else if (OtherEvent.class.isAssignableFrom(message.getPayloadType) {
            // handle SomeOtherEvent
        }
    }
}</programlisting></para>
        </sect2>
        <sect2 xml:id="annotated-event-handlers">
            <title>Annotated Event Handler</title>
            <para>Implementing the EventListener interface can produce a large if-statement and
                verbose plumbing code. Using annotations to demarcate Event Handler methods is a
                cleaner alternative. </para>
            <simplesect>
                <title>
                    <code>AnnotationEventListenerAdapter</code></title>
                <para>The <code>AnnotationEventListenerAdapter</code> can wrap any object into an
                    event listener. The adapter will invoke the most appropriate event handler
                    method available. These event handler methods must be annotated with the
                        <code>@EventHandler</code> annotation.</para>
                <para>The <code>AnnotationEventListenerAdapter</code>, as well as the
                        <code>AbstractAnnotatedAggregateRoot</code>, use
                        <code>ParameterResolver</code>s to resolve the value that should be passed
                    in the parameters of methods annotated with <code>@EventHandler</code>. By
                    default, Axon provides a number of parameter resolvers that allow you to use the
                    following parameter types: <itemizedlist>
                        <listitem>
                            <para>The first parameter is always the payload of the Event
                                message</para>
                        </listitem>
                        <listitem>
                            <para>Parameters annotated with <code>@MetaData</code> will resolve to
                                the Meta Data value with the key as indicated on the annotation. If
                                    <code>required</code> is <code>false</code> (default),
                                    <code>null</code> is passed when the meta data value is not
                                present. If <code>required</code> is <code>true</code>, the resolver
                                will not match and prevent the method from being invoked when the
                                meta data value is not present.</para>
                        </listitem>
                        <listitem>
                            <para>Parameters of type <code>MetaData</code> will have the entire
                                    <code>MetaData</code> of an <code>EventMessage</code>
                                injected.</para>
                        </listitem>
                        <listitem>
                            <para>Parameters of type <code>org.joda.time.DateTime</code> will
                                resolve to the timestamp of the <code>EventMessage</code>. This is
                                the time at which the Event was generated.</para>
                        </listitem>
                        <listitem>
                            <para>Parameters assignable to Message will have the entire
                                    <code>EventMessage</code> injected (if the message is assignable
                                to that parameter). If the first parameter is of type message, it
                                effectively matches an Event of any type, even if generic parameters
                                would suggest otherwise. Due to type erasure, Axon cannot detect
                                what parameter is expected. In such case, it is best to declare a
                                parameter of the payload type, followed by a parameter of type
                                Message.</para>
                        </listitem>
                        <listitem>
                            <para>When using Spring and <code>&lt;axon:annotation-config/></code> is
                                declared, any other parameters will resolve to autowired beans, if
                                exactly one autowirable candidate is available in the application
                                context. This allows you to inject resources directly into
                                    <code>@EventHandler</code> annotated methods.</para>
                        </listitem>
                    </itemizedlist></para>
                <para>You can configure additional ParameterResolvers by extending the
                    ParameterResolverFactory class and creating a file named
                        <code>/META-INF/service/org.axonframework.common.annotation.ParameterResolverFactory</code>
                    containing the fully qualified name of the implementing class. Alternatively,
                    you can register your implementation at runtime using
                        <code>ParameterResolverFactory.registerFactory()</code>. Make sure to do so
                    before any adapters are created, otherwise handlers may have been initialized
                    without those parameter resolvers.</para>
                <para>In all circumstances, exactly one event handler method is invoked per listener
                    instance. Axon will search the most specific method to invoke, in the following
                    order: <orderedlist>
                        <listitem>
                            <para>On the actual instance level of the class hierarchy (as returned
                                by <code>this.getClass()</code>), all annotated methods are
                                evaluated </para>
                        </listitem>
                        <listitem>
                            <para>If one or more methods are found of which all parameters can be
                                resolved to a value, the method with the most specific type is
                                chosen and invoked </para>
                        </listitem>
                        <listitem>
                            <para>If no methods are found on this level of the class hierarchy, the
                                super type is evaluated the same way</para>
                        </listitem>
                        <listitem>
                            <para>When the top level of the hierarchy is reached, and no suitable
                                event handler is found, the event is ignored.</para>
                        </listitem>
                    </orderedlist><programlisting language="java">// assume EventB extends EventA 
// and    EventC extends EventB

public class TopListener {

    @EventHandler
    public void handle(EventA event) {
    }

    @EventHandler
    public void handle(EventC event) {
    }
}

public class SubListener extends TopListener {

    @EventHandler
    public void handle(EventB event) {
    }

}</programlisting>In
                    the example above, the <code>SubListener</code> will receive all instances of
                        <code>EventB</code> as well as <code>EventC</code> (as it extends
                        <code>EventB</code>). In other words, the <code>TopListener</code> will not
                    receive any invocations for <code>EventC</code> at all. Since
                        <code>EventA</code> is not assignable to <code>EventB</code> (it's its
                    superclass), those will be processed by <code>TopListener</code>.</para>
                <para>The constructor of the <code>AnnotationEventListenerAdapter</code> takes two
                    parameters: the annotated bean, and the <code>EventBus</code>, to which the
                    listener should subscribe. You can subscribe and unsubscribe the event listener
                    using the <code>subscribe()</code> and <code>unsubscribe()</code> methods on the
                    adapter. Alternatively, you can use
                        <code>AnnotationEventListenerAdapter.subscribe(listener, eventBus)</code> to
                    create and subscribe the listener in one invocation.</para>
                <tip>
                    <para>If you use Spring, you can automatically wrap all annotated event
                        listeners with an adapter automatically by adding
                            <code>&lt;axon:annotation-config/></code> to your application context.
                        Axon will automatically find and wrap annotated event listeners inside an
                            <code>AnnotationEventListenerAdapter</code> and register them with an
                        event bus.</para>
                </tip>
            </simplesect>
        </sect2>
        <sect2>
            <title>Asynchronous event processing</title>
            <warning>
                <para>This feature will be deprecated in favor of an asynchronous implementation of
                    a <code>Cluster</code>.</para>
            </warning>
            <para>By default, event listeners process events in the thread that dispatches them.
                This means that the thread that executes the command will have to wait untill all
                event handling has finished. For some types of event listeners this is not the
                optimal form of processing. Asynchronous event processing improves the scalability
                of the application, with the penalty of added complexity to deal with "eventual
                consistency". With the Axon Framework, you can easily convert any event handler into
                an asynchronous event handler by wrapping it in an
                <code>AsynchronousEventHandlerWrapper</code>
                or, when using annotations, adding
                the type-level
                <code>AsynchronousEventListener</code>
                annotation.
            </para>
            <para>The
                <code>AsynchronousEventHandlerWrapper</code>
                needs some extra configuration to
                make an event handler asynchronous. The first thing that the wrapper needs is an
                <code>Executor</code>, for example a <code>ThreadPoolExecutor</code>. The second
                is the <code>SequencingPolicy</code>, a definition of which events may be processed
                in parallel, and which sequentially. The last one is optional: the
                <code>TransactionManager</code>, which enables you to run event processing
                within a transaction. The next pragraphs will provide more details about the
                configuration options.
            </para>
            <para>The
                <code>Executor</code>
                is responsible for executing the event processing. The
                actual implementation most likely depends on the environment that the application
                runs in and the SLA of the event handler. An example is the
                <code>ThreadPoolExecutor</code>, which maintains a pool of threads for the event
                handlers to use to process events. The
                <code>AsynchonousEventHandlerWrapper</code>
                will manage the processing of incoming events in the provided executor. If an
                instance of a
                <code>ScheduledThreadPoolExecutor</code>
                is provided, the
                <code>AsynchronousEventHandlerWrapper</code>
                will automatically leverage its
                ability to schedule processing in the cases of delayed retries. See
                <xref linkend="transactionmanager"/>
                for more information about transactions.
            </para>
            <para>The
                <code>SequencingPolicy</code>
                defines whether events must be handled
                sequentially, in parallel or a combination of both. Policies return a sequence
                identifier of a given event. If two events have the same sequence identifier, this
                means that they must be handled sequentially be the event handler. A
                <code>null</code>
                sequence identifier means the event may be processed in
                parallel with any other event.
            </para>
            <para>Axon provides a number of common policies you can use: <itemizedlist>
                    <listitem>
                        <para>The <code>FullConcurrencyPolicy</code> will tell Axon that this event
                            handler may handle all events concurrently. This means that there is no
                            relationship between the events that require them to be processed in a
                            particular order. </para>
                    </listitem>
                    <listitem>
                        <para>The <code>SequentialPolicy</code> tells Axon that all events must be
                            processed sequentially. Handling of an event will start when the
                            handling of a previous event is finished. For annotated event handlers,
                            this is the default policy. </para>
                    </listitem>
                    <listitem>
                        <para>
                            <code>SequentialPerAggregatePolicy</code> will force domain events that
                            were raised from the same aggregate to be handled sequentially. However,
                            events from different aggregates may be handled concurrently. This is
                            typically a suitable policy to use for event listeners that update
                            details from aggregates in database tables. </para>
                    </listitem>
                </itemizedlist>Besides these provided policies, you can define your own. All
                policies must implement the <code>EventSequencingPolicy</code> interface. This
                interface defines a single method, <code>getSequenceIdentifierFor</code>, that
                returns the identifier sequence identifier for a given event. Events for which an
                equal sequence identifer is returned must be processed sequentially. Events that
                produce a different sequence identifier may be processed concurrently. For
                performance reasons, policy implementations should return <code>null</code> if the
                event may be processed in parallel to any other event. This is faster, because Axon
                does not have to check for any restrictions on event processing. </para>
            <para>A
                <code>TransactionManager</code>
                can be assigned to a
                <code>AsynchronousEventHandlerWrapper</code>
                to add transactional processing of
                events. To optimize processing, events can be processed in small batches inside a
                transaction. The transaction manager has the ability to influence the size of these
                batches and can decide to either commit, skip or retry event processing based on the
                result of a batch. See
                <xref linkend="transactionmanager"/>
                for more
                information.
            </para>
        </sect2>
        <sect2 xml:id="transactionmanager">
            <title>Managing transactions in asynchronous event handling</title>
            <warning>
                <para>This feature will be deprecated in favor of an asynchronous implementation of
                    a <code>Cluster</code>.</para>
            </warning>
            <para>In some cases, your event handlers have to store data in systems that use
                transactions. Starting and committing a transaction for each single event has a big
                performance impact. In Axon, events are processed in batches. The batch size depends
                of the number of events that need to be processed and the settings provided by the
                event handler. By default, the batch size is set to the number of events available
                in the processing queue at the time a batch starts.</para>
            <note>
                <para>Typically, when using synchronous event handling, the transaction boundary is
                    managed at the Command Bus level. Asynchronous event handlers, on the other
                    hand, run in another thread and are often unable to act within the same
                    transaction. The transaction managers used by event handlers should not be
                    confused with the transaction interceptors, which are used with the Command Bus.
                    See <xref linkend="transactional-interceptor"/> for more information about transactions in
                    the command bus.</para>
            </note>
            <para>In most cases, event handling is done using a thread pool executor, or scheduler.
                The scheduler will schedule batches of event processing as soon as event become
                available. When a batch is completed, the scheduler will reschedule processing of
                the next batch, as long as more events are available. The smaller a batch, the more
                "fair" the distribution of event handler processing is, but also the more scheduling
                overhead you create.</para>
            <para>When an event listener is wrapped with the
                <code>AsynchronousEventHandlerWrapper</code>, you can configure a
                <code>TransactionManager</code>
                to handle transactions for the event listener.
                The transaction manager can, based on the information in the
                <code>TransactionStatus</code>
                object, decide to start, commit or rollback a
                transaction to an external system.
            </para>
            <para>The
                <code>beforeTransaction(TransactionStatus)</code>
                method is invoked just
                before Axon will start handling an event batch. You can use the TransactionStatus
                object to configure the batch before it is started. For example, you can change the
                maximum number of events that may run in the batch.
            </para>
            <para>The
                <code>afterTransaction(TransactionStatus)</code>
                method is invoked after the
                batch has been processed, but before the scheduler has scheduled the next batch.
                Based on the value of <code>isSuccessful()</code>, you can decide to commit or
                rollback the underlying transaction.
            </para>
            <simplesect>
                <title>Configuring transactional batches</title>
                <para>There are a number of settings you can use on the
                    <code>TransactionStatus</code>
                    object.
                </para>
                <para>You can configure a yielding policy, which gives the scheduler an indication
                    of that to do when a batch has finished, but more events are available for
                    processing. Use
                    <code>DO_NOT_YIELD</code>
                    if you want the scheduler to continue
                    processing immediately as long as new events are available for processing. The
                    <code>YIELD_AFTER_TRANSACTION</code>
                    policy will tell the scheduler to
                    reschedule the next batch for processing when a thread is available. The first
                    will make sure events are processed earlier, while the latter provides a fairer
                    execution of events, as yielding provides waiting thread a chance to start
                    processing. The choice of yielding policy should be driven by the SLA of the
                    event listener.
                </para>
                <para>You can set the maximum number of events to handle within a transaction using
                    <code>setMaxTransactionSize(int)</code>. The default of this value is the
                    number of events ready for processing at the moment the transaction started.
                </para>
            </simplesect>
            <simplesect>
                <title>Error handling</title>
                <para>When an event handler throws an exception, for example because a data source
                    is not available, the transaction is marked as failed. In that case,
                    <code>isSuccessful()</code>
                    on the
                    <code>TransactionStatus</code>
                    object
                    will return
                    <code>false</code>
                    and
                    <code>getException()</code>
                    will return the
                    exception that the scheduler caught. It is the responsibility of the event
                    listener to rollback or commit any active underlying transactions, based on the
                    information provided by these methods.
                </para>
                <para>The event handler can provide a policy
                        <code>setRetryPolicy(RetryPolicy)</code> to tell the scheduler what to do in
                    such case. There are three policies, each for a specific scenario: <itemizedlist>
                        <listitem>
                            <para><code>RETRY_TRANSACTION</code> tells the event handler scheduler
                                that the entire transaction should be retried. It will reschedule
                                all the events in the current transaction for processing. This
                                policy is suitable when the event listener processes events to a
                                transactional data source that rolls back an entire transaction. </para>
                        </listitem>
                        <listitem>
                            <para><code>RETRY_LAST_EVENT</code> is the policy that tells the
                                scheduler to only retry the last event in the transaction. This is
                                suitable if the underlying data source does not support transactions
                                or if the transaction was committed without the last event. </para>
                        </listitem>
                        <listitem>
                            <para><code>SKIP_FAILED_EVENT</code> will tell the scheduler to ignore
                                the exception and continue processing with the next event. The event
                                listener can still try to commit the underlying transaction to
                                persist any changed made while processing other events in this
                                transaction. This is the default policy. </para>
                        </listitem>
                    </itemizedlist></para>
                <para>Note that the
                    <code>SKIP_FAILED_EVENT</code>
                    is the default policy. For event
                    handlers that use an underlying mechanism to perform actions, this might not be
                    a suitable policy. Exceptions resulting from errors in these underlying systems
                    (such as databases or email clients) would cause events to be ignored when the
                    underlying system is unavailable. In error situations, the event listener should
                    inspect the exception (using the
                    <code>getException()</code>
                    method) and decide
                    whether it makes sense to retry processing of this event. If that is the case,
                    it should set the
                    <code>RETRY_LAST_EVENT</code>
                    or
                    <code>RETRY_TRANSACTION</code>
                    policy, depending on the transactional
                    behavior of the underlying system.
                </para>
                <para>When the chosen policy forces a retry of event processing, the processing is
                    delayed by the number of milliseconds defined in the
                    <code>retryInterval</code>
                    property. The default interval is 5 seconds.
                </para>
            </simplesect>
            <simplesect>
                <title>Provided TransactionManager implementations</title>
                <para>Currently, Axon Framework provides one TransactionManager implementation, the
                        <code>SpringTransactionManager</code>. This implemenation uses Spring's
                        <code>PlatformTransactionManager</code> as underlying transaction mechanism.
                    That means the <code>SpringTransactionManager</code> can manage any transactions
                    in resources that Spring supports.</para>
            </simplesect>
        </sect2>
    </sect1>
    <sect1>
        <title>Distributing the Event Bus</title>
        <para>In a distributed environment, it may be necessary to transport Event Messages between
            JVM's. The ClusteringEventBus has a possiblity to define an
                <code>EventBusTerminal</code>. This is an interface to a mechansim that publishes
            Events to all relevant clusters. Some EventBusTerminal implementations allow
            distribution of Events over multiple JVM's.</para>
        <para>
            <note>
                <title>Background of the name "Terminal"</title>
                <para>While most developers association the word "terminal" to a thin client
                    computer connected to a mainframe, the association to make here is slightly
                    different. In Neurology, an Axon Terminal is an endpoint of an Axon that
                    transmits electronic impulses from one Neuron to another.</para>
                <para>For more detailed information, see <link
                        xmlns:xlink="http://www.w3.org/1999/xlink"
                        xlink:href="http://en.wikipedia.org/wiki/Axon_terminal"
                        >http://en.wikipedia.org/wiki/Axon_terminal</link>.</para>
            </note>
        </para>
        <sect2>
            <title>SpringAMQPTerminal</title>
            <para>The Spring AMQP Terminal uses the Spring AMQP module to transmit events to an AMQP
                compatible message broker, such as Rabbit MQ. It also connects local clusters to
                queues on that message broker.</para>
            <para>The <code>axon-amqp</code> namespace
                    (<code>http://www.axonframework.org/schema/amqp</code>) allows you to configure
                an AMQP Terminal by adding the &lt;axon-amqp:terminal> element to the Spring
                application context. On this element, you can define different properties for the
                terminal, as well as a configuration containing defaults to use to connect each
                cluster to an AMQP Queue.</para>
            <para>The configure the Spring AMQP Terminal "manually", you need to specify a number of
                beans in your application context:</para>
            <itemizedlist>
                <listitem>
                    <para>The <code>ListenerContainerLifecycleManager</code> is responsible for
                        creating ListenerContainers. These are the Spring classes that listen for
                        messages on the AMQP Queues and forward them to the processing components.
                        The <code>ListenerContainerLifecycleManager</code> allows you to configure
                        the number of messages to process in a single transaction, the number of
                        messages it may read ahead, etc.</para>
                    <para>Note that the <code>ListenerContainerLifecycleManager</code> must be
                        defined as a top-level bean.</para>
                </listitem>
                <listitem>
                    <para>An AMQP <code>ConnectionFactory</code>, which creates the connections to
                        the AMQP Message Broker. Spring provides the
                            <code>CachingConnectionFactory</code>, which is a sensible
                        default.</para>
                </listitem>
                <listitem>
                    <para>The Spring AMQPTerminal itself, which connects the aforementioned
                        components to the event publishers and event listeners. There is a large
                        number of configuration options that allow you to tweak the terminal's behavior:
                        <itemizedlist>
                            <listitem>
                                <para>transactional: indicates whether the messages should be
                                    dispatched to the AMQP Broker inside a transaction. This is
                                    especially useful when multiple events need to be sent either
                                    completely, or not at all.</para>
                            </listitem>
                            <listitem>
                                <para>durable: indicates whether messsages should be durable (i.e.
                                    survive a Broker shutdown) or not. Obviously, message durability
                                    involves a performance impact.</para>
                            </listitem>
                            <listitem>
                                <para>connectionFactory: configures the ConnectionFactory to use.
                                    Useful when the application context contains more than one
                                    instance. Otherwise, the only available instance is
                                    autowired.</para>
                            </listitem>
                            <listitem>
                                <para>serializer: the serializer to serialize the MetaData and
                                    Payload of EventMessages with. Defaults to an autowired
                                    serializer.</para>
                            </listitem>
                            <listitem>
                                <para>exchangeName or exchange: defines the exchange (either defined
                                    by the name, or by a reference to an Exchange bean) to which
                                    published Event Messages should be sent. Defaults to
                                    "Axon.EventBus"</para>
                            </listitem>
                            <listitem>
                                <para>queueNameResolver: defines the mechanism that chooses the
                                    Queue that each Cluster should be connected to. Defaults to a
                                    resolver that locates the property "AMQP.QueueName" or otherwise
                                    "ClusterName" in the Meta Data of a Cluster. If both properties
                                    are not available, it reverts to the Queue named
                                        <emphasis>exchangeName</emphasis> + ".Default".</para>
                            </listitem>
                            <listitem>
                                <para>routingKeyResolver: defines the mechanism that generates an
                                    AMQP routing key for an outgoing Message. Defaults to a routing
                                    key resolver that returns the package name of the Message's
                                    payload. Routing keys can be used by echanges to define which
                                    queues should receive a (copy of a) Message</para>
                            </listitem>
                            <listitem>
                                <para>listenerContainerLifecycleManager: when the application
                                    context contains more than one, defines which
                                    listenerContainerLifecycleManager instance to use.</para>
                            </listitem>
                        </itemizedlist></para>
                </listitem>
            </itemizedlist>
            <para>When a cluster is selected for an Event Listener, it will be registered with the
                terminal. At that point, the terminal will check if there is any cluster-specific
                configuration available. It does so by checking the <code>AMQP.Config</code>
                MetaData value. If that value is an instance of
                    <code>AMQPConsumerConfiguration</code> (such as
                    <code>SpringAMQPConsumerConfiguration</code>) any settings configured there will
                override the defaults set on the terminal itself. This allows you to specify
                different behavior (such as transaction size) for different clusters.</para>
            <programlisting>// XML Configuration for a Cluster with AMQPConsumerConfiguration
&lt;axon:cluster id="myDefaultCluster" default="true">
    &lt;axon:meta-data>
        &lt;entry key="AMQP.Config">
            &lt;axon-amqp:configuration transaction-size="20000"/>
        &lt;/entry>
    &lt;/axon:meta-data>
&lt;/axon:cluster></programlisting>
        </sect2>
    </sect1>
</chapter>
