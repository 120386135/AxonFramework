<?xml version="1.0" encoding="UTF-8"?>
<!--
    ~ Copyright (c) 2010. Axon Framework
    ~
    ~ Licensed under the Apache License, Version 2.0 (the "License");
    ~ you may not use this file except in compliance with the License.
    ~ You may obtain a copy of the License at
    ~
    ~     http://www.apache.org/licenses/LICENSE-2.0
    ~
    ~ Unless required by applicable law or agreed to in writing, software
    ~ distributed under the License is distributed on an "AS IS" BASIS,
    ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    ~ See the License for the specific language governing permissions and
    ~ limitations under the License.
-->
<chapter id="repositories-and-event-stores" xmlns="http://docbook.org/ns/docbook">
    <title>Repositories and Event Stores</title>
        <para>The repository is the mechanism that provides access to aggregates. The repository
        acts as a gateway to the actual storage mechanism used to persist the data. In CQRS, the
        repositories only need to be able to find aggregates based on their unique identifier. Any
        other types of queries should be performed against the query database, not the
        Repository.</para>
    <para>In the Axon Framework, all repositories must implement the <code>Repository</code>
        interface. This interface prescribes two methods: <code>load(identifier)</code> and
            <code>save(aggregate)</code>. </para>
        <para>Depending on your underlying persistence storage and auditing needs, there are a
            number of base implementations that provide basic functionality needed by most
            repositories. Axon Framework makes a distinction between repositories that save the
            current state of the aggregate (see <xref linkend="standard-repositories"/>), and those
            that store the events of an aggregate (see <xref linkend="event-sourcing-repositories"/>).
        </para>
        <sect1 xml:id="standard-repositories">
            <title>Standard repositories</title>
        <para>Standard repositories store the actual state of an Aggregate. Upon each change, the
            new state will overwrite the old. This makes it possible for the query components of the
            application to use the same information the command component also uses. This could,
            depending on the type of application you are creating, be the simplest solution. If that
            is the case, Axon provides some building blocks that help you implement such a
            repository.</para>
        <para>Note that the Repository interface does not prescribe a
                <code>delete(identifier)</code> method. This is because not all types of
            repositories use that functionality. Of course, nothing witholds you from adding it to
            your repository implementation.</para>
            <simplesect>
                <title><code>AbstractRepository</code></title>
            </simplesect>
            <para>The most basic implementation of the repository is AbstractRepository. It takes
            care of the event publishing when an aggregate is saved. The actual persistence
            mechanism must still be implemented. This implementation doesn't provide any locking
            mechanism and expects the underlying data storage mechanism to provide it. </para>
            <simplesect xml:id="locking-repository">
                <title><code>LockingRepository</code></title>
            </simplesect>
            <para>If the underlying data store does not provide any locking mechanism to prevent
                concurrent modifications of aggregates, consider using the abstract
                <code>LockingRepository</code>
                implementation. Besides providing event
                dispatching logic, it will also ensure that aggregates are not concurrently
                modified.
            </para>
            <para>You can configure the
                <code>LockingRepository</code>
                to use an optimistic locking
                strategy, or a pessimistic one. When the optimistic lock detects concurrent access,
                the second thread saving an aggregate will receive a
                <code>ConcurrencyException</code>. The pessimistic lock will prevent concurrent
                access to the aggregate alltogether.
            </para>
        </sect1>
        <sect1 xml:id="event-sourcing-repositories">
            <title>Event Sourcing repositories</title>
            <para>Aggregate roots that implement the
                <code>EventSourcedAggregateRoot</code>
                interface can be stored in an event sourcing repository. Those repositories do not
                store the aggregate itself, but the series of events generated by the aggregate.
                Based on these events, the state of an aggregate can be restored at any time.
            </para>
            <simplesect>
                <title>
                    <code>EventSourcingRepository</code>
                </title>
                <para>The abstract
                    <code>EventSourcingRepository</code>
                    implementation provides the
                    basic functionality needed by any event sourcing repository in the
                    AxonFramework. It depends on an <code>EventStore</code>, which abstracts the
                    actual storage mechanism for the events. See <xref linkend="implementing-an-eventstore"/>.
                </para>
                <para>The EventSourcingRepository has two abstract methods:
                    <code>getTypeIdentifier()</code>
                    and
                    <code>instantiateAggregate(identifier)</code>. The first is a value passed
                    to the event store that provides information about the type of aggregate that
                    the events relate to. A good starting point to use as return value is the simple
                    name of a class (i.e. the fully qualified class name withouth the package name).
                    The second method requires you to create an uninitialized instance of the
                    aggregate using the given identifier. The repository will initialize this
                    instance with the events obtained from the event store.
                </para>
            </simplesect>
            <simplesect>
                <title><code>CachingEventSourcingRepository</code></title>
                <para>Initializing aggregates based on the events can be a time-consuming effort,
                compared to the direct aggregate loading of the simple repository implementations.
                The <code>CachingEventSourcingRepository</code> provides a cache from which
                aggregates can be loaded if available. You can configure any jcache implementation
                with this repository. Note that this implementation can only use caching in
                combination with a pessimistic locking strategy.</para>
            </simplesect>
        </sect1>
        <sect1 xml:id="implementing-an-eventstore">
            <title>Event store implementations</title>
            <para>Event Sourcing repositories need an event store to store and load events from
                aggregates. Typically, event stores are capable of storing events from multiple
                types of aggregates, but it is not a requirement. </para>
            <para>Axon provides two implementations of event stores, both are capable of storing all
                domain events (those that extend the <code>DomainEvent</code> class). These event
                stores use an <code>EventSerializer</code> to serialize and deserialize the event.
                By default, Axon provides an implementation of the Event Serializer that serializes
                events to XML: the <code>XStreamEventSerializer</code>. </para>
            <simplesect>
                <title><code>FileSystemEventStore</code></title>
                <para>The <code>FileSystemEventStore</code> stores the events in a file on the file
                    system. It provides good performance and easy configuration. The only downside
                    of this event store is that is does not provide transaction support and doesn't
                    cluster very well. The only configuration needed is the location where the event
                    store may store its files and the serializer to use to actually serialize and
                    deserialize the events. Note that the provided url must end on a slash. This is
                    due to the way Spring's <code>Resource</code> implementations work. </para>
            </simplesect>
            <simplesect>
                <title><code>JpaEventStore</code></title>
                <para>The <code>JpaEventStore</code> stores events in a JPA-compatible data source.
                    Unlike the XStream version, the <code>JPAEventStore</code> supports
                    transactions. The JPA event store can also load events based on their
                    timestamps. </para>
                <para>To use the <code>JpaEventStore</code>, you must have the
                    <code>javax.persistence</code> annotations on your classpath. Furthermore, you
                should configure your persistence context (defined in
                    <code>META-INF/persistence.xml</code> file) to contain the classes
                    <code>org.axonframework.eventstore.jpa.DomainEventEntry</code> and
                    <code>org.axonframework.eventstore.jpa.SnapshotEventEntry</code>. </para>
                <para>Below is an example configuration of a persistence context configuration: </para>
                <programlistingco>
                    <areaspec units="LineColumn">
                        <area coords="2 40" id="persistence-unit-name-co"/>
                        <area coords="3 62" id="domain-event-entry-co"/>
                    </areaspec>
                    <programlisting language="xml"><![CDATA[<persistence xmlns="http://java.sun.com/xml/ns/persistence" version="1.0">
    <persistence-unit name="eventStore" transaction-type="RESOURCE_LOCAL">
        <class>org...eventstore.jpa.DomainEventEntry</class>
        <class>org...eventstore.jpa.SnapshotEventEntry</class>
    </persistence-unit>
</persistence>]]></programlisting>
                    <calloutlist>
                        <callout arearefs="persistence-unit-name-co">
                            <para>In this sample, there is is specific persistence unit for the
                                event store. You may, however, choose to add the third line to any
                                other persistence unit configuration. </para>
                        </callout>
                        <callout arearefs="domain-event-entry-co">
                            <para>This line registers the <code>DomainEventEntry</code> (the class
                                used by the <code>JpaEventStore</code>) with the persistence context.
                            </para>
                        </callout>
                    </calloutlist>
                </programlistingco>
            </simplesect>
            <simplesect>
            <title>Implementing your own event store</title>
            <para>If you have specific requirements for an event store, it is quite easy to
                implement one using different underlying data sources. Reading and appending events
                is done using a <code>DomainEventStream</code>, which is quite similar to iterator
                implementations. </para>
            <tip>
                <para>The <code>SimpleDomainEventStream</code> class will make the contents of a
                    sequence (<code>List</code> or <code>array</code>) of <code>DomainEvent</code>
                    instances accessible as event stream. </para>
            </tip>
        </simplesect>
        <simplesect>
            <title>Influencing the serialization process</title>
            <para>Event Stores need a way to serialize the Domain Event to prepare it for storage.
                By default, Axon uses the <code>XStreamEventSerializer</code>, which uses XStream
                (see <link xmlns:ns1="http://www.w3.org/1999/xlink" ns1:href="http://xstream.codehaus.org/">xstream.codehaus.org</link>) to
                serialize Domain Events into XML and vice versa. XStream is very fast and is more
                flexible than Java Serialization. For example, if you remove a field from a class,
                you can still deserialize instances from that class using the old XML. XStream will
                simply ignore that field. Furthermore, the result of XStream serialization is human
                readable. Quite useful for logging and debugging purposes.</para>
            <para>The XStreamEventSerializer can be configured. You can define aliases it should use
                for certain packages, classes or even fields. Besides being a nice way to shorten
                potentially long names, aliases can also be used when class definitions of event
                change. For more information about aliases, visit the XStream website: <link xmlns:ns1="http://www.w3.org/1999/xlink" ns1:href="http://xstream.codehaus.org/">xstream.codehaus.org</link>.</para>
            <para>You may also implement your own Event Serializer, simply by creating a class that
                implements <code>EventSerializer</code>, and configuring the Event Store to use that
                implementation instead of the default.</para>
        </simplesect>
        </sect1>
        <sect1 xml:id="using-snapshot-events">
            <title>Using Snapshot Events</title>
            <para>When aggregates live for a long time, and their state constantly change, they will
            generate a large amount of events. Having to load all these events in to rebuild an
            aggregate's state may have a big performance impact. The snapshot event is a domain
            event with a special purpose: it summarises an arbitrary amount of events into a single
            one. By regularly creating and storing a snapshot event, the event store does not have
            to return long lists of events. Just the last snapshot events and all events that
            occurred after the snapshot was made.</para>
            <para>For example, items in stock tend to change quite often. Each time an item is sold,
                an event reduces the stock by one. Every time a shipment of new items comes in, the
                stock is incremented by some larger number. If you sell a hundred items each day,
                you will produce at least 100 events per day. After a few days, your system will
                spend too much time reading in all these events just to find out wheter it should
                raise an "ItemOutOfStockEvent". A single snapshot event could replace a lot of these
                events, just by storing the current number of items in stock.</para>
            <simplesect>
                <title>Storing Snapshot Events</title>
                <para>Both the <code>JpaEventStore</code> and the <code>FileSystemEventStore</code>
                    are capable of storing snapshot events. They provide a special method that
                    allows a <code>DomainEvent</code> to be stored as a snapshot event. You have to
                    initialize the snapshot event completely, including the aggregate identifier and
                    the sequence number. There is a special constructor on the
                    <code>DomainEvent</code> for this purpose. The sequence number must be equal
                    to the sequence number of the last event that was included in the state that the
                    snapshot represents. In most cases, you can use the
                    <code>getLastCommittedEventSequenceNumber()</code> on the
                    <code>VersionedAggregate</code> (which each event sourced aggregate
                    implements) to obtain the sequence number to use in the snapshot event.</para>
                <para>When a snapshot is stored in the Event Store, it will automatically use that
                    snapshot to summarize all prior events and return it in their place. Both event
                    store implementations allow for concurrent creation of snapshots. This means
                    they allow snapshots to be stored while another process is adding Events for the
                    same aggregate. This allows the snapshotting process to run as a separate
                    process alltogether.</para>
                <note>
                    <para>Normally, you can archive all events once they are part of a snapshot
                        event. Snapshotted events will never be read in again by the event store in
                        regular operational scenario's. However, if you want to be able to
                        reconstruct aggregate state prior to the moment the snapshot was created,
                        you must keep the events up to that date.</para>
                </note>
            </simplesect>
            <simplesect>
                <title>Triggering snapshot creation</title>
                <para>Snapshot creation can be triggered by a number of factors, for example the
                    number of events created since the last snapshot, the time to initialize an
                    aggregate exceeds a certain threshold, time-based, etc. Currently, Axon does not
                    provide a triggering mechanism (yet).</para>
                <para>However, Axon does provide an interface that instances that produce snapshots
                    should implement: <code>SnapshotProducer</code>. Typically, this interface is
                    implemented by an aggregate root, since that is typically the only object that
                    has full access to the aggregate's full state information.</para>
            </simplesect>
            <simplesect>
                <title>Initializing an aggregate based on a Snapshot Event</title>
                <para>A snapshot event is just a regular <code>DomainEvent</code>. That means a
                snapshot event is handled just like any other domain event. When using annotations
                to demarcate event handers (<code>@EventHandler</code>), you can annotate a method
                that initializes full aggregate state based on a snapshot event. The code sample
                below shows how snapshot events are treated like any other domain event within the
                aggregate.</para>
            <para>
                <programlisting language="java">public class MyAggregate extends AbstractAnnotatedAggregateRoot {

    // ... code omitted for brevity

    @EventHandler
    protected void handleSomeStateChangeEvent(MyDomainEvent event) {
        // ...
    }

    @EventHandler
    protected void applySnapshot(MySnapshotEvent event) {
        // the snapshot event should contain all relevant state
        this.someState = event.someState;
        this.otherState = event.otherState;
    }
}</programlisting>
            </para>
            </simplesect>
        </sect1>
</chapter>
